# ----------------------------------------------------------------------
#  Copyright (c) 2025 Rayan Zayat
#  All Rights Reserved.
#
#  Author: Rayan Zayat (rayanzayat.com)
#  Description: This code/script is developed and maintained by Rayan Zayat.
#
#  License:
#  You are free to use, modify, and distribute this code for personal or
#  educational purposes, as long as you credit Rayan Zayat as the original author.
#
#  Recommended citation or credit in your project:
#     "Code adapted from Rayan Zayat, 2025"
#
#  Contact: contact@rayanzayat.com
#           rayan.zayat4@gmail.com
# ----------------------------------------------------------------------

import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)  # To hide warnings generated by Scapy
from scapy.all import *
from scapy.layers.dns import DNS, DNSQR, DNSRR
from scapy.layers.inet import IP, TCP, UDP
from scapy.layers.inet6 import IPv6, ICMPv6EchoRequest, ICMPv6EchoReply
from scapy.layers.l2 import ARP
from scapy.layers.l2 import Ether
from scapy.layers.dhcp import DHCP, BOOTP
from scapy.layers.dot11 import Dot11
import argparse
from tabulate import tabulate
import numpy as np
from mac_vendor_lookup import MacLookup
import shutil
import subprocess
import os
import re
import base64
import matplotlib.pyplot as plt
from datetime import datetime
import platform
# -------------------------------------------------------------------------------

# Defining color constants
class bcolors:
    PURPLE = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

record_types = {1: 'A', 28: 'AAAA', 18: 'AFSDB', 42: 'APL',
                257: 'CAA', 60: 'CDNSKEY', 59: 'CDS', 37: 'CERT',
                5: 'CNAME', 62: 'CSYNC', 49: 'DHCID', 32769: 'DLV',
                39: 'DNAME', 48: 'DNSKEY', 43: 'DS', 108: 'EUI48',
                109: 'EUI64', 13: 'HINFO', 55: 'HIP', 65: 'HTTPS',
                45: 'IPSECKEY', 25: 'KEY', 36: 'KX', 29: 'LOC', 15: 'MX',
                35: 'NAPTR', 2: 'NS', 47: 'NSEC', 50: 'NSEC3', 51: 'NSEC3PARAM',
                61: 'OPENPGPKEY', 12: 'PTR', 17: 'RP', 46: 'RRSIG', 24: 'SIG',
                53: 'SMIMEA', 6: 'SOA', 33: 'SRV', 44: 'SSHFP', 64: 'SVCB',
                32768: 'TA', 249: 'TKEY', 52: 'TLSA', 250: 'TSIG', 16: 'TXT',
                256: 'URI', 63: 'ZONEMD',
                255:'ALL', 252:'AXFR', 251:'IXFR', 41:'OPT'}

# Create arguments
parser = argparse.ArgumentParser(description='PCAP File Forensics')
parser.add_argument('-f', '--file', metavar='<file name>', type=str, help='Enter PCAP file name', required=True)  # Mandatory
args = parser.parse_args()


file_name = args.file  # Getting the PCAP file name
if not os.path.isfile(file_name):  # Checking if the file exists
    print(bcolors.RED + f"[-] '{file_name}' file does not exist." + bcolors.ENDC)
    sys.exit(-1)

# Reading the file
print(bcolors.GREEN + f"[+] Reading the PCAP file: {file_name}" + bcolors.ENDC)
pcap_file = rdpcap(file_name)

# -------------------------------------------------------------------------------
# -------------------------------------------------------------------------------

def carve_files_from_pcap():
    if platform.system() == "Linux":  # Ensure function only runs on Linux systems
        output_base = os.path.join(os.getcwd(), "carved_output")  # Base directory for carved files
        tcpflow_out = os.path.join(output_base, "tcpflow_output")  # Directory for tcpflow output
        foremost_out = os.path.join(output_base, "foremost_output")  # Directory for foremost output

        # Ensure clean directories
        for path in [tcpflow_out, foremost_out]:
            if os.path.exists(path):  # Remove existing directory if it exists
                shutil.rmtree(path)  # Delete directory and its contents
            os.makedirs(path)  # Create fresh directory

        try:
            # Step 1: Reconstruct TCP streams from the PCAP file
            subprocess.run(["tcpflow", "-r", file_name, "-o", tcpflow_out], check=True)  # Run tcpflow to extract TCP streams

            # Step 2: Use foremost to carve files from tcpflow output
            subprocess.run(f"foremost -i {tcpflow_out}/* -o {foremost_out}", shell=True, check=True)  # Run foremost on tcpflow results

            print(bcolors.GREEN + bcolors.BOLD + f"\n[+] Carving complete. Check: {foremost_out}" + bcolors.ENDC)  # Notify user that carving finished

            # Step 3: Show audit.txt summary
            audit_path = os.path.join(foremost_out, "audit.txt")  # Path to foremost log file
            if os.path.exists(audit_path):  # Check if audit.txt exists
                print(bcolors.YELLOW + bcolors.BOLD + "\n[+] Foremost Summary (from audit.txt):" + bcolors.ENDC)
                print(bcolors.CYAN + "-" * 50 + bcolors.ENDC)

                carved = False  # Flag to check if any files were extracted
                with open(audit_path, 'r') as audit:  # Open audit.txt for reading
                    for line in audit:  # Iterate through lines in audit log
                        if "files extracted" in line.lower():  # Look for extraction summary
                            carved = True
                            print("   " + line.strip())  # Print number of files extracted

                if not carved:  # If no extracted files were found in audit log
                    print(bcolors.RED + bcolors.BOLD + "[-] No files were carved" + bcolors.ENDC)
            else:
                print(bcolors.RED + bcolors.BOLD + "[!] audit.txt not found â€” carving might have failed or no files were found" + bcolors.ENDC)

        except subprocess.CalledProcessError as e:  # Catch errors from tcpflow or foremost
            print(bcolors.RED + bcolors.BOLD + f"[!] Error during processing: {e}" + bcolors.ENDC)
    else:
        print(bcolors.RED + bcolors.BOLD + "File Carving is not supported on this operating system." + bcolors.ENDC)  # Display error for non-Linux systems
# -------------------------------------------------------------------------------

def analyze_traffic_flow():
    flows = {}  # Dictionary to store flow statistics
    for packet in pcap_file:  # Iterate through each packet in the PCAP
        if IP in packet and (TCP in packet or UDP in packet):  # Process only IP packets with TCP/UDP
            proto = "TCP" if TCP in packet else "UDP"  # Identify protocol
            src_ip = packet[IP].src  # Source IP address
            dst_ip = packet[IP].dst  # Destination IP address
            src_port = packet[TCP].sport if TCP in packet else packet[UDP].sport  # Source port
            dst_port = packet[TCP].dport if TCP in packet else packet[UDP].dport  # Destination port

            # Normalize to handle bi-directional flow (so both directions map to same key)
            if (src_ip, src_port) < (dst_ip, dst_port):
                flow_key = (proto, src_ip, dst_ip, src_port, dst_port)  # Store as-is
            else:
                flow_key = (proto, dst_ip, src_ip, dst_port, src_port)  # Swap order for consistency

            # Initialize new flow entry if not already in dictionary
            if flow_key not in flows:
                flows[flow_key] = {
                    "packets": 0,  # Number of packets in the flow
                    "bytes": 0,  # Total bytes in the flow
                    "first_seen": float(packet.time),  # Timestamp of first packet
                    "last_seen": float(packet.time)   # Timestamp of last packet
                }

            # Update flow statistics
            flows[flow_key]["packets"] += 1  # Increment packet count
            flows[flow_key]["bytes"] += len(packet)  # Add packet size to total bytes
            flows[flow_key]["last_seen"] = packet.time  # Update last seen timestamp

    # Print table headers for flow analysis
    print(bcolors.PURPLE + bcolors.BOLD + "\nTraffic Flow Analysis" + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + "-" * 120 + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"{'Proto':<6} {'Src IP':<15} {'Dst IP':<15} {'SPort':<6} {'DPort':<6} {'Packets':<8} {'Bytes':<10} {'First Seen':<20} {'Duration (s)'}" + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + "-" * 120 + bcolors.ENDC)

    # Print each flow's statistics
    for flow, stats in flows.items():
        proto, src_ip, dst_ip, sport, dport = flow  # Unpack flow information
        first_seen = datetime.fromtimestamp(float(stats["first_seen"])).strftime('%Y-%m-%d %H:%M:%S')  # Format timestamp
        duration = round(stats["last_seen"] - stats["first_seen"], 2)  # Calculate flow duration
        print(
            bcolors.YELLOW + bcolors.BOLD + f"{proto:<6} " + bcolors.ENDC +
            bcolors.BOLD + f"{src_ip:<15} {dst_ip:<15} {sport:<6} {dport:<6} {stats['packets']:<8} {stats['bytes']:<10} {first_seen:<20} {duration}" + bcolors.ENDC
        )

    # Print total number of distinct flows
    print(bcolors.YELLOW + bcolors.BOLD + f"\nTotal number of flows: {len(flows)}" + bcolors.ENDC)

# -------------------------------------------------------------------------------

def detect_dns_poisoning():
    print(bcolors.PURPLE + bcolors.BOLD + "DNS Cache Poisoning Attack\n" + bcolors.ENDC)

    # Get whitelist of trusted domain names from user input
    whitelist_input = input(bcolors.BOLD + "[?] Enter whitelisted domain names separated by commas (Press ENTER to leave it blank): " + bcolors.ENDC)
    whitelisted_domains = set(domain.strip().lower() for domain in whitelist_input.split(",") if domain.strip())

    dns_records = {}  # Store DNS answers per domain
    suspected_domains = []  # Domains suspected of poisoning (multiple conflicting records)
    total_dns = 0  # Total DNS responses analyzed

    txid_guess_tracker = {}  # Track TXID guessing attempts (per domain, rtype, txid, source)
    port_guess_tracker = {}  # Track port guessing attempts (per domain, rtype, port, source)
    bailiwick_violations = set()  # Track out-of-bailiwick violations

    # Ask user for time window size in seconds (default = 10s)
    try:
        window_size = float(input(bcolors.BOLD + "[?] Enter time window size in seconds (Default 10): " + bcolors.ENDC))
    except:
        window_size = 10  # default 10 seconds

    # Ask user for guessing threshold (default = 5 attempts)
    try:
        threshold = int(input(bcolors.BOLD + "[?] Enter number of guessing threshold (Default 5): " + bcolors.ENDC))
    except:
        threshold = 5

    # Iterate through DNS packets in the PCAP
    for packet in pcap_file[DNS]:
        if packet[DNS].qr == 1:  # QR=1 â†’ response packet
            dns = packet[DNS]
            if dns.qd is None or dns.an is None:  # Skip incomplete responses
                continue

            domain = dns.qd.qname.decode(errors="ignore").strip('.').lower()  # Extract queried domain
            total_dns += 1

            if domain in whitelisted_domains:  # Skip trusted domains
                continue

            ip_src = packet[IP].src if packet.haslayer(IP) else "unknown"  # Extract source IP
            mac_src = packet.src if packet.haslayer(Ether) else "unknown"  # Extract source MAC
            pkt_time = packet.time  # Capture timestamp

            # --- Method 1: Conflicting A Records ---
            if domain not in dns_records:
                dns_records[domain] = {"ips": set(), "sources": set()}

            for i in range(dns.ancount):  # Iterate through all answers
                rr = dns.an[i]
                if rr.type == 1:  # A record
                    ip = rr.rdata
                    dns_records[domain]["ips"].add(ip)  # Store IPs
                    dns_records[domain]["sources"].add(f"{ip_src} / {mac_src}")  # Store sources

            # If multiple different IPs from different sources exist â†’ suspicious
            if (len(dns_records[domain]["ips"]) > 1 and len(dns_records[domain]["sources"]) > 1 and domain not in suspected_domains):
                suspected_domains.append(domain)

            # --- Method 2: Excessive TXID/Port Guessing ---
            txid = dns.id  # DNS transaction ID
            sport = packet[UDP].sport if packet.haslayer(UDP) and packet[UDP].sport != 53 else None  # Source port

            for i in range(dns.ancount):
                rr = dns.an[i]
                rtype = rr.type  # Record type (A, CNAME, etc.)

                key1 = (domain, rtype, txid, ip_src, mac_src)  # Tracker for TXID guessing
                key2 = (domain, rtype, sport, ip_src, mac_src)  # Tracker for port guessing

                # Maintain rolling window for TXID guessing
                if key1 not in txid_guess_tracker:
                    txid_guess_tracker[key1] = []
                txid_guess_tracker[key1] = [t for t in txid_guess_tracker[key1] if pkt_time - t[1] <= window_size]
                txid_guess_tracker[key1].append((sport, pkt_time))
                txid_guess_tracker[key1].sort(key=lambda x: x[1])

                # Maintain rolling window for port guessing
                if key2 not in port_guess_tracker and sport is not None:
                    port_guess_tracker[key2] = []
                    port_guess_tracker[key2] = [t for t in port_guess_tracker[key2] if pkt_time - t[1] <= window_size]
                    port_guess_tracker[key2].append((txid, pkt_time))
                    port_guess_tracker[key2].sort(key=lambda x: x[1])

        # --- Method 3: Out-of-Bailiwick Responses ---
        if packet.haslayer(DNS) and packet[DNS].qr == 1:
            dns = packet[DNS]
            if dns.qd and dns.an:
                queried_domain = dns.qd.qname.decode(errors="ignore").strip('.').lower()
                q_parts = queried_domain.split(".")
                queried_root = ".".join(q_parts[-2:]) if len(q_parts) >= 2 else queried_domain

                # Skip if domain or subdomain is whitelisted
                if any(queried_domain == d or queried_domain.endswith("." + d) for d in whitelisted_domains):
                    continue

                for i in range(dns.ancount):
                    rr = dns.an[i]
                    if rr.type == 1 or rr.type == 5:  # A or CNAME record
                        answer_domain = rr.rrname.decode(errors="ignore").strip('.').lower()
                        a_parts = answer_domain.split(".")
                        answer_root = ".".join(a_parts[-2:]) if len(a_parts) >= 2 else answer_domain

                        # Skip if answer domain is whitelisted
                        if any(answer_domain == d or answer_domain.endswith("." + d) for d in whitelisted_domains):
                            continue

                        # If answer domain root differs from queried domain root â†’ bailiwick violation
                        if queried_root != answer_root:
                            bailiwick_violations.add((queried_domain, answer_domain))

    # ---------------- OUTPUT SECTION ----------------
    print(bcolors.YELLOW + f"[+] Total DNS responses analyzed: {total_dns}" + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + "\nSuspected DNS domain names:" + bcolors.ENDC)
    print("-" * 60)

    # Output for Method 1
    if suspected_domains:
        count = 1
        for domain in suspected_domains:
            print(bcolors.YELLOW + bcolors.BOLD + f"[{count}] [!] Domain: {domain}" + bcolors.ENDC)
            print(bcolors.YELLOW + bcolors.BOLD + f"    â†’ IPs: " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(dns_records[domain]['ips'])}" + bcolors.ENDC)
            print(bcolors.YELLOW + bcolors.BOLD + f"    â†’ Sources: " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(dns_records[domain]['sources'])}" + bcolors.ENDC)
            print(bcolors.CYAN + "-" * 60 + bcolors.ENDC)
            count += 1
        print(bcolors.RED + bcolors.BOLD + f"Total number of suspected domains: {len(suspected_domains)}" + bcolors.ENDC)
    else:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No conflicting A records from multiple sources detected" + bcolors.ENDC)

    # Output for Method 2: TXID / Port Guessing
    count = 0
    print(bcolors.CYAN + bcolors.BOLD + "\n[!] DNS TXID / Port Guessing Detection" + bcolors.ENDC)
    detected = False

    # Check port-based guessing
    for (domain, rtype, port, ip_src, mac_src), txid_list in port_guess_tracker.items():
        unique_txids = sorted(set(t[0] for t in txid_list))
        if len(unique_txids) > threshold:  # More TXIDs than threshold = suspicious
            detected = True
            count += 1
            rtype_name = record_types.get(rtype, f"TYPE{rtype}")
            print(bcolors.RED + bcolors.BOLD + f"{[count]}[!] TXID guessing detected"
                  + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + " â†’ Domain: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{domain}"
                  + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", Type: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{rtype_name}"
                  + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", Port: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{port}" + bcolors.ENDC)
            print(bcolors.YELLOW + bcolors.BOLD + f"    â†’ Source: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{ip_src} / {mac_src}"
                  + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", TXIDs: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{unique_txids}")

    # Check TXID-based guessing
    for (domain, rtype, txid, ip_src, mac_src), port_list in txid_guess_tracker.items():
        unique_ports = sorted(set(t[0] for t in port_list))
        if len(unique_ports) > threshold:  # More ports than threshold = suspicious
            detected = True
            count += 1
            rtype_name = record_types.get(rtype, f"TYPE{rtype}")
            print(bcolors.RED + bcolors.BOLD + f"{[count]}[!] Port guessing detected" + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + " â†’ Domain: "
                   + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{domain}"
                   + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", Type: "
                   + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{rtype_name}"
                   + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", TXID: "
                   + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{txid}" + bcolors.ENDC)
            print(bcolors.YELLOW + bcolors.BOLD + f"    â†’ Source: " + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{ip_src} / {mac_src}"
                   + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", Ports: "
                   + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{unique_ports}")

    if not detected:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No excessive TXID or port guessing detected." + bcolors.ENDC)

    # Output for Method 3: Bailiwick violations
    count = 0
    if bailiwick_violations:
        print(bcolors.CYAN + bcolors.BOLD + "\nOut-of-Bailiwick DNS Responses:" + bcolors.ENDC)
        for query, answer in bailiwick_violations:
            count += 1
            print(bcolors.YELLOW + bcolors.BOLD + f"{[count]} [!] Query: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{query}"
                  + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + "  -->  Answered by: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{answer}" + bcolors.ENDC)


# -------------------------------------------------------------------------------

# Detect DHCP Starvation
def detect_dhcp_starvation():
    print(bcolors.PURPLE + bcolors.BOLD + "DHCP Starvation Attack" + bcolors.ENDC)
    try:
        # Ask user for threshold of DHCP Discover packets (default: 100)
        discover_limit = int(input(bcolors.BOLD + "[?] Enter DHCP Discover packet count threshold (Default: 100): " + bcolors.ENDC) or 100)
    except ValueError:
        discover_limit = 100

    try:
        # Ask user for ratio of unique MAC addresses among all Discover packets (default: 0.2)
        mac_ratio = float(input(bcolors.BOLD + "[?] Enter unique MACs ratio threshold (0-1, Default: 0.2): " + bcolors.ENDC) or 0.2)
    except ValueError:
        mac_ratio = 0.9  # fallback if invalid input

    try:
        # Ask user for Offer/Discover ratio threshold (default: 0.1)
        offer_ratio = float(input(bcolors.BOLD + "[?] Enter Offer/Discover ratio threshold (0-1, Default: 0.1): " + bcolors.ENDC) or 0.1)
    except ValueError:
        offer_ratio = 0.1
    print()

    # Initialize counters and sets
    discover_count = 0
    offer_count = 0
    discover_macs = set()  # Store unique MAC addresses from Discover packets

    # Iterate over DHCP packets in PCAP
    for packet in pcap_file[DHCP]:
        msg_type = None
        # Extract DHCP message type (Discover, Offer, etc.)
        for option in packet[DHCP].options:
            if isinstance(option, tuple) and option[0] == 'message-type':
                msg_type = option[1]
                break
        if msg_type is None:
            continue

        # Count Discover packets and collect unique MACs
        if msg_type == 1:  # Discover
            discover_count += 1
            if Ether in packet:
                discover_macs.add(packet[Ether].src)
        # Count Offer packets
        elif msg_type == 2:  # Offer
            offer_count += 1

    # Calculate metrics
    unique_macs = len(discover_macs)  # total distinct MAC addresses
    mac_unique_ratio = unique_macs / discover_count if discover_count else 0
    offer_discover_ratio = offer_count / discover_count if discover_count else 0

    # Display metrics for analysis
    print(bcolors.YELLOW + bcolors.BOLD + f"DHCP Discover count: {discover_count}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"Unique MAC addresses: {unique_macs}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"DHCP Offer count: {offer_count}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"Unique MAC ratio: {mac_unique_ratio:.2%}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"Offer/Discover ratio: {offer_discover_ratio:.2%}" + bcolors.ENDC)

    # Detection logic: suspicious if
    # - High number of Discover packets
    # - Large ratio of unique MAC addresses (indicating spoofing)
    # - Low Offer/Discover ratio (DHCP server overwhelmed)
    suspicious = (discover_count >= discover_limit
                  and mac_unique_ratio >= mac_ratio
                  and offer_discover_ratio <= offer_ratio)

    # Final decision output
    if suspicious:
        print(bcolors.RED + bcolors.BOLD + "[!] DHCP Starvation Attack detected" + bcolors.ENDC)
    else:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No DHCP Starvation Attack detected" + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Detect Rogue DHCP Servers
# This function creates a bar chart showing DHCP server activity.
# It highlights whitelisted servers in green and potential rogue servers in red.
def visualize_dhcp_servers(dhcp_servers, whitelist_ips, whitelist_macs):
    servers = []
    counts = []
    colors = []

    # Process each server in the DHCP data
    for (ip, mac), data in dhcp_servers.items():
        servers.append(f"{ip}\n{mac}")
        counts.append(data['count'])

        # Check if IP or MAC is whitelisted
        if ip in whitelist_ips or mac.lower() in whitelist_macs:
            colors.append('green')  # Whitelisted server
        else:
            colors.append('red')    # Potential rogue server

    # Create the bar chart
    plt.figure(figsize=(10, 6))
    bars = plt.bar(servers, counts, color=colors)

    plt.xlabel('DHCP Servers (IP and MAC)')
    plt.ylabel('Number of Responses Sent')
    plt.title('DHCP Servers Activity')

    # Add response count labels
    for bar in bars:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width() / 2, height, str(height), ha='center', va='bottom')

    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()
    plt.show()


def detect_rogue_dhcp_servers():
    # Prompt user to enter whitelist IPs and MACs
    whitelist_ips_input = input(bcolors.PURPLE + bcolors.BOLD +
                                "[?] Enter whitelist IPs (comma separated), or press Enter to skip: " +
                                bcolors.ENDC).strip()
    whitelist_macs_input = input(bcolors.PURPLE + bcolors.BOLD +
                                "[?] Enter whitelist MACs (comma separated), or press Enter to skip: " +
                                bcolors.ENDC).strip().lower()

    # Convert input to sets for easier checking
    whitelist_ips = set(ip.strip() for ip in whitelist_ips_input.split(",")) if whitelist_ips_input else set()
    whitelist_macs = set(mac.strip() for mac in whitelist_macs_input.split(",")) if whitelist_macs_input else set()

    dhcp_servers = {}  # Dictionary to store each DHCP server's data
    for packet in pcap_file[DHCP]:  # Process each DHCP packet in the PCAP file
        options = packet[DHCP].options
        msg_type = None
        router = None
        dns = None
        subnet = None

        # Extract DHCP options from the packet
        for option in options:
            if isinstance(option, tuple):
                if option[0] == "message-type":
                    msg_type = option[1]  # DHCP message type (Offer, Ack, etc.)
                elif option[0] == "router":
                    router = option[1]    # Default gateway
                elif option[0] == "name_server":
                    dns = option[1]       # DNS server
                elif option[0] == "subnet_mask":
                    subnet = option[1]    # Subnet mask

        try:  # Skip packet if Ether layer is missing
            if msg_type == 2 or msg_type == 5:  # Only Offer or Ack messages
                server_ip = packet[IP].src
                server_mac = packet[Ether].src.lower()
                key = (server_ip, server_mac)

                # Add or update server data
                if key not in dhcp_servers:
                    dhcp_servers[key] = {
                        "count": 1,
                        "routers": set(),
                        "dns": set(),
                        "subnets": set()
                    }
                else:
                    dhcp_servers[key]["count"] += 1

                # Update sent values (routers, DNS, subnets)
                if router:
                    if isinstance(router, list):
                        dhcp_servers[key]["routers"].update(router)
                    else:
                        dhcp_servers[key]["routers"].add(router)
                if dns:
                    if isinstance(dns, list):
                        dhcp_servers[key]["dns"].update(dns)
                    else:
                        dhcp_servers[key]["dns"].add(dns)
                if subnet:
                    dhcp_servers[key]["subnets"].add(subnet)
        except:
            continue  # Skip packet if an error occurs

    # Print textual report
    print(bcolors.PURPLE + bcolors.BOLD + "\nRogue DHCP Server Detection" + bcolors.ENDC)
    print("-" * 90)

    rogue_count = 0  # Counter for potential rogue servers
    for (ip, mac), data in dhcp_servers.items():
        if ip in whitelist_ips or mac in whitelist_macs:
            color = bcolors.GREEN + bcolors.BOLD
            status = "[+] Whitelisted Server"
        else:
            color = bcolors.RED + bcolors.BOLD
            status = "[!] Not in whitelist â†’ Possible Rogue Server"
            rogue_count += 1

        # Print details of each server
        print(f"{color}Server IP: {ip}, MAC: {mac}" + bcolors.ENDC)
        print(bcolors.BOLD + f"  -> Responses Sent: {data['count']}" + bcolors.ENDC)
        print(bcolors.BOLD + f"  -> Routers Sent: {', '.join(data['routers']) if data['routers'] else 'N/A'}" + bcolors.ENDC)
        print(bcolors.BOLD + f"  -> DNS Sent: {', '.join(data['dns']) if data['dns'] else 'N/A'}" + bcolors.ENDC)
        print(bcolors.BOLD + f"  -> Subnets Sent: {', '.join(data['subnets']) if data['subnets'] else 'N/A'}" + bcolors.ENDC)
        print(f"{color}  {status}" + bcolors.ENDC)
        print("-" * 90)

    # Print summary of detected rogue servers
    if rogue_count > 0:
        print(bcolors.RED + bcolors.BOLD + f"[!] {rogue_count} Rogue DHCP server(s) detected." + bcolors.ENDC)
    else:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No Rogue DHCP servers detected." + bcolors.ENDC)

    # Call the chart visualization function
    visualize_dhcp_servers(dhcp_servers, whitelist_ips, whitelist_macs)

# -------------------------------------------------------------------------------

# Detect FTP Brute Force
def detect_ftp_brute_force():
    print(bcolors.PURPLE + bcolors.BOLD + "FTP Brute Force Attack:" + bcolors.ENDC)

    # Prompt user for failure threshold
    try:
        failure_threshold = int(input(bcolors.BOLD + "[?] Enter failures threshold (Default: 5): " + bcolors.ENDC))
    except:
        failure_threshold = 5  # Default value if input invalid

    # Prompt user for time window in seconds
    try:
        time_window = float(input(bcolors.BOLD + "[?] Enter time window in seconds (Default: 5): " + bcolors.ENDC))
    except:
        time_window = 5.0  # Default value if input invalid

    attempts = {}  # Dictionary to count login attempts per IP
    failures = {}  # Dictionary to store failure timestamps per IP
    credentials = {}  # Dictionary to store captured credentials per IP

    # Iterate over all packets in the PCAP file
    for packet in pcap_file:
        if packet.haslayer(IP) and packet.haslayer(TCP):
            ip_src = packet[IP].src  # Source IP (client)
            ip_dst = packet[IP].dst  # Destination IP (server)
            sport = packet[TCP].sport  # Source port
            dport = packet[TCP].dport  # Destination port

            # Detect login requests (FTP control port 21)
            if dport == 21 and packet.haslayer(Raw):  # Only packets with payload
                payload = packet[Raw].load.decode(errors="ignore").strip()

                # Collect entered credentials
                if payload.upper().startswith("USER") or payload.upper().startswith("PASS"):
                    if ip_src not in credentials:
                        credentials[ip_src] = []
                    credentials[ip_src].append(payload)

                    # Count login attempts
                    if ip_src in attempts:
                        attempts[ip_src] += 1
                    else:
                        attempts[ip_src] = 1

            # FTP Response Codes -> 530 User cannot log in | 331 Password Required | 230 User logged in
            # Detect FTP server error responses (530, 331, 230, etc.)
            elif sport == 21 and packet.haslayer(Raw):
                try:
                    payload = packet[Raw].load.decode(errors="ignore")
                    # Check for failure messages
                    if "530" in payload or "User cannot log in" in payload or "Incorrect password" in payload or "Not logged in" in payload:
                        ip = ip_dst  # Client IP who attempted login
                        timestamp = datetime.fromtimestamp(float(packet.time))

                        if ip not in failures:
                            failures[ip] = []
                        failures[ip].append(timestamp)
                except:
                    continue  # Skip packet if decoding fails

    # Print header for suspicious IPs table
    print(bcolors.YELLOW + bcolors.BOLD + "\n[!] Suspicious IPs with high FTP login failures:" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + "-" * 60 + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + f"{'IP Address':<20} {'Attempts':<10} {'Failures':<10}" + bcolors.ENDC)
    print(bcolors.BOLD + "-" * 60 + bcolors.ENDC)

    suspicious_ips = []  # List to store detected suspicious IPs

    # Analyze failures per IP within the time window
    for ip in failures:
        timestamps = sorted(set(failures[ip]))  # Remove duplicate timestamps
        for i in range(len(timestamps)):
            count = 1
            start_time = timestamps[i]
            for j in range(i + 1, len(timestamps)):
                delta = (timestamps[j] - start_time).total_seconds()
                if delta <= time_window:
                    count += 1
                else:
                    break
            # Mark as suspicious if failures exceed threshold
            if count >= failure_threshold:
                suspicious_ips.append(ip)
                total_attempts = attempts.get(ip, 0)
                print(bcolors.YELLOW + bcolors.BOLD + f"{ip:<20}" + bcolors.ENDC +
                      bcolors.RED + bcolors.BOLD + f" {total_attempts // 2:<10} {count:<10}" + bcolors.ENDC)
                break  # Stop checking further windows for this IP

    # Print result summary
    if not suspicious_ips:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No FTP brute force attack detected." + bcolors.ENDC)
    else:
        # Print captured credentials for suspicious IPs
        print(bcolors.CYAN + bcolors.BOLD + "\nEntered Credentials from Suspicious IPs:" + bcolors.ENDC)
        print(bcolors.BOLD + "-" * 60 + bcolors.ENDC)
        for ip in suspicious_ips:
            creds = credentials.get(ip, [])
            if creds:
                print(bcolors.YELLOW + bcolors.BOLD + f"\n-> {ip}:" + bcolors.ENDC)
                for line in creds:
                    print(bcolors.RED + bcolors.BOLD + f"    â†’ {line}" + bcolors.ENDC)
            else:
                print(bcolors.GREEN + bcolors.BOLD + f"\n[+] {ip}: No credentials captured." + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Detect MAC Spoofing
def detect_mac_spoofing():
    mac_to_ips = {}  # Dictionary to map MAC addresses to observed IP addresses

    # Iterate over all packets in the PCAP file
    for pkt in pcap_file:
        if pkt.haslayer(Ether) and pkt.haslayer(IP):  # Check for Ethernet and IP layers
            ip = pkt[IP].src.strip()       # Extract source IP
            mac = pkt[Ether].src.lower()   # Extract source MAC (lowercase for consistency)

            # Map MAC to IPs
            if mac not in mac_to_ips:
                mac_to_ips[mac] = [ip]      # First IP observed for this MAC
            elif ip not in mac_to_ips[mac]:
                mac_to_ips[mac].append(ip)  # Add new IP to existing MAC entry

    # Print MAC Spoofing results (MAC addresses associated with multiple IPs)
    print(bcolors.PURPLE + bcolors.BOLD + "MAC Spoofing Attack\n" + bcolors.ENDC)
    mac_spoofing_found = False
    for mac, ips in mac_to_ips.items():
        if len(ips) > 1:  # More than one IP mapped to same MAC â†’ possible spoofing
            mac_spoofing_found = True
            print(bcolors.RED + bcolors.BOLD + "[!] MAC Address" + bcolors.ENDC +
                  bcolors.RED + bcolors.BOLD + f" {mac}" + bcolors.ENDC +
                  bcolors.YELLOW + f" is associated with multiple IP addresses: " + bcolors.ENDC +
                  bcolors.BOLD + f"{', '.join(ips)}" + bcolors.ENDC)
    if not mac_spoofing_found:  # No MAC associated with multiple IPs
        print(bcolors.GREEN + bcolors.BOLD + "[+] No MAC Spoofing attack detected" + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Detect MAC Flooding
def detect_mac_flooding():
    print(bcolors.PURPLE + bcolors.BOLD + "MAC Flooding Detection per Time Window\n" + bcolors.ENDC)

    # Prompt user for time window size in seconds with validation
    while True:
        try:
            window_size = int(input(bcolors.BOLD + "Enter time window size in seconds: " + bcolors.ENDC))
            if window_size <= 0:
                print(bcolors.RED + bcolors.BOLD + "Please enter a positive integer for window size: " + bcolors.ENDC)
                continue
            break
        except:
            print(
                bcolors.RED + bcolors.BOLD + "Invalid input! Please enter a valid integer for window size: " + bcolors.ENDC)

    # Prompt user for threshold of unique MAC addresses with validation
    while True:
        try:
            mac_threshold = int(input(bcolors.BOLD + "Enter threshold for unique MAC addresses: " + bcolors.ENDC))
            if mac_threshold <= 0:
                print(bcolors.RED + bcolors.BOLD + "Please enter a positive integer for MAC threshold: " + bcolors.ENDC)
                continue
            break
        except:
            print(
                bcolors.RED + bcolors.BOLD + "Invalid input! Please enter a valid integer for MAC threshold: " + bcolors.ENDC)

    start_time = pcap_file[0].time  # Start time of capture
    macs_per_window = {}  # Dictionary to store MAC addresses per time window

    # Iterate over all packets in PCAP file
    for packet in pcap_file:
        if packet.haslayer(Ether):
            current_time = packet.time
            window_idx = int((current_time - start_time) // window_size)  # Determine window index
            if window_idx not in macs_per_window:
                macs_per_window[window_idx] = []
            macs_per_window[window_idx].append(packet[Ether].src)  # Add MAC address to corresponding window

    flagged_windows = 0  # Counter for suspicious windows

    # Print header for results
    print(
        bcolors.CYAN + bcolors.BOLD + f"\n{'Window #':<10} {'Time Range (s)':<20} {'Unique MACs':<12} {'Status'}" + bcolors.ENDC)
    print(bcolors.CYAN + "-" * 60 + bcolors.ENDC)

    # Analyze each time window
    for window_idx in sorted(macs_per_window.keys()):
        mac_list = macs_per_window[window_idx]
        unique_macs_count = len(set(mac_list))  # Count unique MAC addresses
        time_range = bcolors.BOLD + f"{window_idx * window_size} - {(window_idx + 1) * window_size}"
        status = ""
        if unique_macs_count > mac_threshold:  # Check against threshold
            flagged_windows += 1
            status = bcolors.RED + bcolors.BOLD + "[! Suspicious]" + bcolors.ENDC
        else:
            status = bcolors.GREEN + bcolors.BOLD + "Normal" + bcolors.ENDC

        # Print result for this window
        print(bcolors.BOLD + f"{window_idx:<10} {time_range:<24} {unique_macs_count:<12} {status}")

    # Print summary of MAC flooding detection
    if flagged_windows == 0:
        print(bcolors.GREEN + bcolors.BOLD + "\n[-] No MAC flooding detected per time window." + bcolors.ENDC)
    else:
        print(
            bcolors.RED + bcolors.BOLD + f"\n[!] Suspicious MAC flooding detected in {flagged_windows} time window(s)." + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Detect ARP spoofing
def normalize_mac(mac):
    #
    # If it's type of bytes -> Convert it to hex string separated by ":"
    if isinstance(mac, (bytes, bytearray)):
        return ':'.join(f"{b:02x}" for b in mac)
    # If it's type of String -> Make it lowercase
    return str(mac).lower()

def detect_arp_spoofing():
    print("\n" + bcolors.PURPLE + bcolors.BOLD + "ARP Spoofing Detection" + bcolors.ENDC)

    # Step 1: Build trusted map from observed IP traffic
    trusted_ip_mac = {}  # Maps each IP to its known MAC address

    for packet in pcap_file:
        if packet.haslayer(Ether) and packet.haslayer(IP):
            ip = packet[IP].src
            mac = normalize_mac(packet[Ether].src)  # Normalize MAC to lowercase
            if ip not in trusted_ip_mac:
                trusted_ip_mac[ip] = mac  # Store first observed MAC for each IP

    # Step 2: Check ARP packets (requests and replies) against trusted map
    detected = False       # Flag to indicate if spoofing detected
    reported = set()       # Keep track of already reported events to avoid duplicates

    for packet in pcap_file:
        if packet.haslayer(ARP):
            arp_layer = packet[ARP]
            claimed_ip = arp_layer.psrc        # IP claimed in ARP packet
            claimed_mac = normalize_mac(arp_layer.hwsrc)  # MAC claimed in ARP packet
            arp_type = "Request" if arp_layer.op == 1 else "Reply"  # Determine ARP type

            # Compare claimed MAC to trusted MAC
            if claimed_ip in trusted_ip_mac:
                real_mac = trusted_ip_mac[claimed_ip]
                if claimed_mac != real_mac:
                    key = (claimed_ip, claimed_mac, arp_layer.op)
                    if key not in reported:  # Report each spoofing event once
                        reported.add(key)
                        detected = True
                        print(bcolors.RED + bcolors.BOLD + f"[!] ARP Spoofing Detected ({arp_type})" + bcolors.ENDC)
                        print(bcolors.YELLOW + bcolors.BOLD + f"    Claimed IP : {claimed_ip}" + bcolors.ENDC)
                        print(bcolors.YELLOW + bcolors.BOLD + f"    MAC in ARP : {claimed_mac}" + bcolors.ENDC)
                        print(bcolors.BLUE + bcolors.BOLD + f"    Real MAC   : {real_mac}" + bcolors.ENDC)
                        print(bcolors.YELLOW + "-" * 50 + bcolors.ENDC)

    # If no spoofing detected, print confirmation
    if not detected:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No ARP Spoofing attack detected" + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Get all usernames & passwords
def get_all_usernames_passwords():
    # Print header
    print(bcolors.PURPLE + bcolors.BOLD + "Captured Credentials from HTTP, FTP, Telnet, POP3, SMTP, IMAP\n" + bcolors.ENDC)

    # Initialize dictionary to store credentials per protocol
    credentials = {
        "HTTP": [],
        "FTP": [],
        "Telnet": [],
        "POP3": [],
        "SMTP": [],
        "IMAP": []
    }

    # Initialize stats counter per protocol
    stats = {k: 0 for k in credentials}

    # POP3 session state storage
    pop3_state = {}  # session (ip_src, ip_dst) â†’ {"user": ...}

    # Buffer to collect single character input for Telnet
    char_buffer = {}

    # Telnet flags
    telnet_cred_found = False
    telnet_state = None
    print_telnet_welcome = True

    # Iterate through each packet in the pcap file
    for packet in pcap_file:
        if not packet.haslayer(Raw):
            continue  # Skip packets without payload
        try:
            payload = packet[Raw].load.decode(errors="ignore")  # Decode payload safely
        except:
            continue

        # Determine source IP
        ip = packet[IP].src if packet.haslayer(IP) else "Unknown"

        # ------------------------------
        # HTTP Basic Authentication
        if "Authorization: Basic" in payload:
            m = re.search(r"Authorization: Basic ([A-Za-z0-9+/=]+)", payload)
            if m:
                b64 = m.group(1)
                try:
                    decoded = base64.b64decode(b64).decode(errors="ignore")
                    credentials["HTTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ Basic Auth: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{decoded}" + bcolors.ENDC)
                except:
                    credentials["HTTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ Basic Auth (Invalid): " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{b64}" + bcolors.ENDC)
                stats["HTTP"] += 1

        # HTTP POST Form login detection
        if "POST" in payload and "log=" in payload and "pwd=" in payload:
            u = re.search(r"log=([^&]+)", payload)
            p = re.search(r"pwd=([^&]+)", payload)
            if u and p:
                # Store username and password from POST
                credentials["HTTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ POST user: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{u.group(1)}" + bcolors.ENDC)
                credentials["HTTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ POST pass: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{p.group(1)}" + bcolors.ENDC)
                stats["HTTP"] += 2

        # ------------------------------
        # FTP credentials detection
        if "USER " in payload:
            username = payload.split("USER ")[1].split("\r")[0]  # Extract username
            credentials["FTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ USER: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{username}" + bcolors.ENDC)
            stats["FTP"] += 1
        if "PASS " in payload:
            password = payload.split("PASS ")[1].split("\r")[0]  # Extract password
            credentials["FTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ PASS: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{password}" + bcolors.ENDC)
            stats["FTP"] += 1

        # ------------------------------
        # POP3 protocol detection
        if packet.haslayer(TCP) and (packet[TCP].dport == 110 or packet[TCP].sport == 110):
            session = (packet[IP].src, packet[IP].dst) if packet.haslayer(IP) else "Unknown"
            if session not in pop3_state:
                pop3_state[session] = {"user": None}

            lines = payload.strip().splitlines()
            for line in lines:
                if line.upper().startswith("USER "):
                    pop3_state[session]["user"] = line[5:].strip()  # Store username
                elif line.upper().startswith("PASS "):
                    password = line[5:].strip()
                    username = pop3_state[session].get("user", "")
                    entry = bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ USER: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{username}" \
                            + bcolors.ENDC + bcolors.BLUE + bcolors.BOLD + " / PASS: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{password}" + bcolors.ENDC
                    if entry not in credentials["POP3"]:
                        credentials["POP3"].append(entry)
                        stats["POP3"] += 1
                    pop3_state[session]["user"] = None  # Clear after use

        # ------------------------------
        # IMAP LOGIN detection
        if packet.haslayer(TCP) and packet[TCP].dport == 143 and "LOGIN" in payload.upper():
            parts = payload.strip().split()
            if len(parts) >= 3:
                u, p = parts[-2], parts[-1]
                credentials["IMAP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ LOGIN: "
                                           + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{u}"
                                           + bcolors.ENDC + bcolors.BLUE + bcolors.BOLD + " / "
                                           + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{p}")
                stats["IMAP"] += 1

        # ------------------------------
        # Telnet credentials detection
        IAC = 255
        SE = 240
        SB = 250

        if packet.haslayer(TCP) and packet.haslayer(IP):
            tcp = packet[TCP]
            ip_src = packet[IP].src
            ip_dst = packet[IP].dst

            # Check if packet belongs to Telnet session
            if tcp.sport == 23 or tcp.dport == 23:
                raw_bytes = bytes(packet[Raw].load)
                result = bytearray()  # Store cleaned payload

                # Remove Telnet control commands (IAC sequences)
                i = 0
                while i < len(raw_bytes):
                    if raw_bytes[i] == IAC:
                        if i + 1 < len(raw_bytes):
                            command = raw_bytes[i + 1]
                            if command == SB:  # Subnegotiation block
                                end = raw_bytes.find(bytes([IAC, SE]), i + 2)
                                if end != -1:
                                    i = end + 2
                                else:
                                    break
                            elif i + 2 < len(raw_bytes):  # Standard 3-byte IAC command
                                i += 3
                            else:
                                break
                    else:
                        result.append(raw_bytes[i])
                        i += 1

                # Decode cleaned Telnet payload
                try:
                    telnet_payload = result.decode('utf-8', errors='replace')
                except:
                    telnet_payload = "<decode error>"

                # Track Telnet session state
                session = (ip_src, ip_dst) if tcp.dport == 23 else (ip_dst, ip_src)
                if tcp.sport == 23:
                    if ("login:" in telnet_payload.lower() or "username:" in telnet_payload.lower()) and "last login:" not in telnet_payload.lower():
                        telnet_state = "waiting_username"
                    elif "password:" in telnet_payload.lower():
                        telnet_state = "waiting_password"

                # Collect characters from client
                elif tcp.dport == 23 and (telnet_state == "waiting_username" or telnet_state == "waiting_password"):
                    if session not in char_buffer:
                        char_buffer[session] = ""
                    if len(telnet_payload) == 1 and telnet_payload.isprintable():
                        char_buffer[session] += telnet_payload
                    elif len(telnet_payload) > 1 and any(c.isprintable() for c in telnet_payload):
                        if char_buffer[session]:
                            # Print captured Telnet credentials
                            if print_telnet_welcome:
                                print(bcolors.PURPLE + bcolors.BOLD + "[Telnet] Credentials:" + bcolors.ENDC)
                                print_telnet_welcome = False
                            print(bcolors.BLUE + bcolors.BOLD + f"[Client â†’ Server] {ip_src}:{tcp.sport} â†’ {ip_dst}:{tcp.dport}" + bcolors.ENDC)
                            if telnet_state == "waiting_username":
                                print(bcolors.YELLOW + bcolors.BOLD + f"Username: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{repr(char_buffer[session])}" + bcolors.ENDC)
                            elif telnet_state == "waiting_password":
                                print(bcolors.YELLOW + bcolors.BOLD + f"Password: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{repr(char_buffer[session])}" + bcolors.ENDC)
                            char_buffer[session] = ""
                            stats["Telnet"] += 1

                    # Reset buffer at end of line
                    if '\r' in payload or '\n' in payload:
                        if char_buffer[session]:
                            if print_telnet_welcome:
                                print(bcolors.PURPLE + bcolors.BOLD + "[Telnet] Credentials:" + bcolors.ENDC)
                                print_telnet_welcome = False
                            print(bcolors.BLUE + bcolors.BOLD + f"[Client â†’ Server] {ip_src}:{tcp.sport} â†’ {ip_dst}:{tcp.dport}")
                            if telnet_state == "waiting_username":
                                print(bcolors.YELLOW + bcolors.BOLD + f"Username: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{repr(char_buffer[session])}" + bcolors.ENDC)
                            elif telnet_state == "waiting_password":
                                print(bcolors.YELLOW + bcolors.BOLD + f"Password: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{repr(char_buffer[session])}" + bcolors.ENDC)
                            char_buffer[session] = ""
                            stats["Telnet"] += 1
                            if not telnet_cred_found:
                                telnet_cred_found = True
                            telnet_state = None

        # ------------------------------
        # Base64-encoded AUTH detection (POP3 or SMTP)
        if packet.haslayer(TCP) and packet.haslayer(Raw):
            tcp = packet[TCP]
            dport = tcp.dport
            sport = tcp.sport
            try:
                payload_str = packet[Raw].load.decode(errors="ignore").strip()
            except:
                continue

            if "AUTH LOGIN" in payload_str or re.fullmatch(r"[A-Za-z0-9+/=]{6,}", payload_str):
                b64_input = payload_str.strip()
                if len(b64_input) % 4 != 0:
                    continue  # skip invalid base64
                try:
                    decoded = base64.b64decode(b64_input).decode(errors="ignore").strip()
                except:
                    continue
                if not decoded or not decoded.isprintable() or len(decoded) < 3:
                    continue
                entry = bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ AUTH (Base64): " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{decoded}"
                if dport in [110] or sport in [110]:  # POP3
                    if entry not in credentials["POP3"]:
                        credentials["POP3"].append(entry)
                        stats["POP3"] += 1
                elif dport in [25, 465, 587] or sport in [25, 465, 587]:  # SMTP
                    if entry not in credentials["SMTP"]:
                        credentials["SMTP"].append(entry)
                        stats["SMTP"] += 1
                else:  # unknown â†’ assume SMTP
                    if entry not in credentials["SMTP"]:
                        credentials["SMTP"].append(entry)
                        stats["SMTP"] += 1

    # ------------------------------
    # Print summary results
    if telnet_cred_found:
        print(bcolors.GREEN + bcolors.BOLD + "\n[+] Credentials for Telnet found")
    else:
        print(bcolors.RED + bcolors.BOLD + "\n[-] No credentials found for Telnet")

    # Print credentials per protocol
    for proto, entries in credentials.items():
        if entries:
            print(bcolors.PURPLE + bcolors.BOLD + f"\n[{proto}] Credentials:" + bcolors.ENDC)
            for line in entries:
                print(bcolors.GREEN + bcolors.BOLD + line + bcolors.ENDC)

    # Print overall credential summary per protocol
    found = False
    print(bcolors.PURPLE + bcolors.BOLD + "\nCredential Summary per Protocol:" + bcolors.ENDC)
    for proto in stats:
        print(bcolors.BOLD + f"{proto:<12}: {stats[proto]} entries" + bcolors.ENDC)
        if stats[proto] > 0 and proto != "Telnet":
            found = True
    if not found:
        print(bcolors.RED + bcolors.BOLD + "\n[-] No credentials found for HTTP, FTP, POP3, SMTP, IMAP" + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Get information about an IP address
def get_ip_address_info():
    # Ask user for target IP
    specified_ip = input(bcolors.YELLOW + bcolors.BOLD + "Enter the target IP address: " + bcolors.ENDC)

    # Initialize general statistics
    count = 0  # Number of packets from specified IP
    protocols = set()  # Protocols used
    dst_ip_addresses = set()  # Unique destination IPs
    mac_src_addresses = set()  # Unique source MAC addresses
    mac_dst_addresses = set()  # Unique destination MAC addresses
    tcp_port_numbers = set()  # TCP destination ports
    udp_port_numbers = set()  # UDP destination ports
    dst_ip_count = {}  # Count of each destination IP
    packet_sizes = []  # Sizes of packets

    # Initialize dictionary to store packets per flow (5-tuple)
    flows = {}

    for packet in pcap_file:
        try:
            if not packet.haslayer(Ether):  # Skip if no Ethernet layer
                continue

            if packet.haslayer(IP):
                ip_layer = packet[IP]

                if ip_layer.src == specified_ip:
                    count += 1

                    # Track destination IPs
                    dst_ip = ip_layer.dst
                    dst_ip_addresses.add(dst_ip)
                    dst_ip_count[dst_ip] = dst_ip_count.get(dst_ip, 0) + 1

                    # Track MAC addresses
                    mac_src_addresses.add(packet[Ether].src)
                    mac_dst_addresses.add(packet[Ether].dst)

                    # Track TCP/UDP ports
                    if packet.haslayer(TCP):
                        tcp_port_numbers.add(packet[TCP].dport)
                    elif packet.haslayer(UDP):
                        udp_port_numbers.add(packet[UDP].dport)

                    # Track packet sizes
                    packet_sizes.append(len(packet))

                    # Collect protocols (exclude Raw and Padding)
                    for layer in packet.layers():
                        name = str(layer).split(".")[-1].replace("'", "").replace(">", "")
                        if name not in ["Raw", "Padding"]:
                            protocols.add(name)

                    # -------------------------
                    # Flow analysis (5-tuple)
                    proto = "TCP" if packet.haslayer(TCP) else "UDP" if packet.haslayer(UDP) else None
                    if proto:
                        sport = packet[TCP].sport if proto == "TCP" else packet[UDP].sport
                        dport = packet[TCP].dport if proto == "TCP" else packet[UDP].dport
                        flow_id = (ip_layer.src, ip_layer.dst, sport, dport, proto)

                        if flow_id not in flows:
                            flows[flow_id] = {"timestamps": [], "sizes": []}

                        flows[flow_id]["timestamps"].append(packet.time)
                        flows[flow_id]["sizes"].append(len(packet))
                    # -------------------------

        except:
            continue

    total = len(pcap_file)  # Total packets in PCAP

    # Most contacted destination IP
    most_contacted_ip = max(dst_ip_count, key=dst_ip_count.get) if dst_ip_count else "N/A"

    # Average packet size
    avg_packet_size = round(sum(packet_sizes) / len(packet_sizes), 2) if packet_sizes else 0

    # -------------------------
    # Calculate total flow duration (sum of individual flow durations)
    total_flow_duration = 0
    for flow, data in flows.items():
        data["timestamps"].sort()
        flow_duration = data["timestamps"][-1] - data["timestamps"][0] if len(data["timestamps"]) > 1 else 0
        total_flow_duration += flow_duration
    # -------------------------

    # -------------------------
    # Calculate packet rate based on first and last packet timestamps for the IP
    all_timestamps = []
    for data in flows.values():
        all_timestamps.extend(data["timestamps"])
    all_timestamps.sort()

    duration = all_timestamps[-1] - all_timestamps[0] if len(all_timestamps) > 1 else 0
    pps = round(count / duration, 2) if duration > 0 else 0
    # -------------------------

    # Output
    print(bcolors.PURPLE + bcolors.BOLD + f"IP Address Statistics: " + bcolors.ENDC + bcolors.BOLD + f"{specified_ip}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Sent Packets: " + bcolors.ENDC + bcolors.BOLD + f"{count}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Percentage of all packets: " + bcolors.ENDC + bcolors.BOLD + f"{round(count / total * 100, 2)}%" + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + f"\n[+] Destination IPs: " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(dst_ip_addresses)}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Most Frequent Destination: " + bcolors.ENDC + bcolors.BOLD + f"{most_contacted_ip}" + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + f"\n[+] Protocols Used ({len(protocols)}): " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(sorted(protocols))}" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + f"\n[+] Source MAC Addresses: " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(mac_src_addresses)}" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + f"\n[+] Destination MAC Addresses: " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(mac_dst_addresses)}" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + f"\n[+] TCP Ports: " + bcolors.ENDC + bcolors.BOLD + f"{sorted(tcp_port_numbers) if tcp_port_numbers else 'None'}" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + f"\n[+] UDP Ports: " + bcolors.ENDC + bcolors.BOLD + f"{sorted(udp_port_numbers) if udp_port_numbers else 'None'}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Average Packet Size: " + bcolors.ENDC + bcolors.BOLD + f"{avg_packet_size} bytes" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Total Flow Duration: " + bcolors.ENDC + bcolors.BOLD + f"{round(total_flow_duration, 2)} seconds" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Packet Rate: " + bcolors.ENDC + bcolors.BOLD + f"{pps} packets/sec" + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Gather all IP addresses
def extract_ips_macs(pcap_file):
    # Initialize dictionary to store IPs, MACs, and NIC vendors
    addresses = {'IP Address':[], 'MAC Address':[], 'NIC Vendor':[]}

    # Dictionary to cache MAC prefix to vendor mapping
    mac_vendors = {}

    # Iterate through each packet in the pcap file
    for packet in pcap_file:
        # Check if packet has both IP and Ethernet layers
        if(packet.haslayer(IP) and packet.haslayer(Ether)):
            # Process only new IP addresses
            if(packet[IP].src not in addresses['IP Address']):
                addresses['IP Address'].append(packet[IP].src)  # Add IP address
                addresses['MAC Address'].append(packet[Ether].src)  # Add MAC address

                # Check if MAC vendor is already cached
                if(packet[Ether].src[:8] in mac_vendors):
                    addresses['NIC Vendor'].append(mac_vendors[packet[Ether].src[:8]])
                else:
                    # Lookup NIC vendor using MacLookup library
                    try:
                        temp_mac_vendor = MacLookup().lookup(packet[Ether].src[:8])
                    except:
                        temp_mac_vendor = "Not Found"  # Handle missing vendor
                    addresses['NIC Vendor'].append(temp_mac_vendor)
                    # Cache the MAC vendor for future packets
                    mac_vendors[packet[Ether].src[:8]] = temp_mac_vendor

    # Print a table of IP Address, MAC Address, and NIC Vendor
    print(tabulate(addresses, headers="keys", tablefmt="fancy_grid"))

    # Print a separator line
    print("-" * 150)

    # Extract unique NIC vendors (excluding "Not Found")
    mac_vendors_set = set(list(mac_vendors.values()))
    list_for_numpy = [[vendor] for vendor in mac_vendors_set if vendor != "Not Found"]

    # Print a table of unique NIC Vendors
    print(tabulate(np.array(list_for_numpy).reshape(len(list_for_numpy),1), headers=['NIC Vendors'], tablefmt="fancy_grid"))

# -------------------------------------------------------------------------------

# Gather all domain names
def extract_domain_names(pcap_file):
    # Initialize dictionary to store extracted DNS information
    domain_names = {"No.": [], "ID": [], "Query": [], "Response": [], "Record Type": []}

    seen = set()  # Set to track unique (Query, Response) pairs
    count = 0     # Counter for numbering entries

    # Iterate through each packet in the pcap file
    for packet in pcap_file:
        # Process only packets that contain both DNS query and DNS response
        if packet.haslayer(DNSQR) and packet.haslayer(DNSRR):
            query = packet[DNSQR].qname.decode(errors="ignore").strip(".")  # Extract queried domain name
            qtype = packet[DNSQR].qtype  # Extract query type (A, AAAA, CNAME, etc.)
            dns_id = packet[DNS].id      # Extract DNS transaction ID

            # Extract DNS response data
            if packet[DNSRR].rdata:
                try:
                    # Decode response if it's in bytes
                    if isinstance(packet[DNSRR].rdata, bytes):
                        response = packet[DNSRR].rdata.decode(errors="ignore").strip(".")
                    else:
                        response = str(packet[DNSRR].rdata).strip(".")
                except:
                    response = "-"  # Fallback if decoding fails
            else:
                response = "-"  # No response data available

            # Skip duplicate query-response pairs
            pair = (query, response)
            if pair in seen:
                continue
            seen.add(pair)

            # Save valid and unique DNS record
            count += 1
            domain_names["No."].append(count)
            domain_names["ID"].append(dns_id)
            domain_names["Query"].append(query)
            domain_names["Response"].append(response)
            domain_names["Record Type"].append(record_types.get(qtype, f"Type {qtype}"))  # Map query type to human-readable format

    # Display the extracted DNS records in a formatted table
    print(tabulate(domain_names, headers="keys", tablefmt="fancy_grid"))

# ----------------------------------------------------------------------------------------

# Get DHCP, DNS, and Routers Addresses
def get_dhcp_dns_router_addresses(pcap_file):
    # Print header for function output
    print(bcolors.PURPLE + bcolors.BOLD + "Get DHCP & DNS & Router IP Addresses" + bcolors.ENDC)

    # Initialize sets to store unique addresses
    dhcp_ip_addresses = set()
    dns_ip_addresses = set()
    router_ip_addresses = set()

    # Iterate through each packet in the pcap file
    for packet in pcap_file:
        # Check if packet contains DHCP or BOOTP layer
        if packet.haslayer(DHCP) or packet.haslayer(BOOTP):
            # Only process DHCP ACK messages (op = 2 indicates server response)
            if packet[BOOTP].op == 2:
                options = packet[DHCP].options  # Extract DHCP options
                for opt in options:
                    try:
                        if isinstance(opt, tuple):  # Ensure option is a key-value tuple
                            key, value = opt[0], opt[1]

                            # Extract DHCP Server IP
                            if key == "server_id":
                                dhcp_ip_addresses.add(value)

                            # Extract DNS Server IP(s)
                            elif key == "name_server":
                                if isinstance(value, list):
                                    for dns in value:
                                        dns_ip_addresses.add(dns)
                                else:
                                    dns_ip_addresses.add(value)

                            # Extract Router IP(s)
                            elif key == "router":
                                if isinstance(value, list):
                                    for router in value:
                                        router_ip_addresses.add(router)
                                else:
                                    router_ip_addresses.add(value)
                    except:
                        continue  # Skip invalid options

    # Print DHCP Server IP addresses
    if dns_ip_addresses:
        print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] DHCP Server IP Addresses - {len(dns_ip_addresses)}" + bcolors.ENDC)
        count = 1
        for ip in dhcp_ip_addresses:
            print(bcolors.BOLD + f" {count}- {ip}" + bcolors.ENDC)
            count += 1
    else:
        print(bcolors.RED + bcolors.BOLD + f"\n[-] No DHCP Server IP addresses detected" + bcolors.ENDC)

    # Print DNS Server IP addresses
    if dhcp_ip_addresses:
        print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] DNS Server IP Addresses - {len(dhcp_ip_addresses)}" + bcolors.ENDC)
        count = 1
        for ip in dns_ip_addresses:
            print(bcolors.BOLD + f" {count}- {ip}" + bcolors.ENDC)
            count += 1
    else:
        print(bcolors.RED + bcolors.BOLD + f"\n[-] No DNS Server IP addresses detected" + bcolors.ENDC)

    # Print Router IP addresses
    if router_ip_addresses:
        print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Router IP Addresses - {len(router_ip_addresses)}" + bcolors.ENDC)
        count = 1
        for ip in router_ip_addresses:
            print(bcolors.BOLD + f" {count}- {ip}" + bcolors.ENDC)
            count += 1
    else:
        print(bcolors.RED + bcolors.BOLD + f"\n[-] No Router IP addresses detected" + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Identify the used protocols
def get_protocols_used():
    # Print header for protocol analysis
    print(bcolors.PURPLE + bcolors.BOLD + "\nProtocol Analysis:" + bcolors.ENDC)

    # Initialize Layer 2 protocol counters
    layer2_counts = {
        "Wi-Fi (802.11)": 0,
        "Ethernet (802.3)": 0,
        "ARP": 0,
        "VLAN": 0,
        "Other": 0
    }

    # Initialize Layer 3 & 4 protocol counters
    protocol_counts = {
        "TCP": 0,
        "UDP": 0,
        "ICMP": 0,
        "ICMPv6": 0,
        "Other": 0
    }

    # Initialize common Application Layer protocols with ports
    app_protocols = {
        "HTTP": {"count": 0, "ports": [80]},
        "HTTPS": {"count": 0, "ports": [443]},
        "QUIC": {"count": 0, "ports": [443]},
        "FTP": {"count": 0, "ports": [20, 21]},
        "DNS": {"count": 0, "ports": [53]},
        "SMTP": {"count": 0, "ports": [25, 587]},
        "SSH": {"count": 0, "ports": [22]},
        "TELNET": {"count": 0, "ports": [23]},
        "DHCP": {"count": 0, "ports": [67, 68]},
        "POP3": {"count": 0, "ports": [110]},
        "IMAP": {"count": 0, "ports": [143]},
        "SMB": {"count": 0, "ports": [445]},
        "NTP": {"count": 0, "ports": [123]},
        "LDAP": {"count": 0, "ports": [389]},
        "SIP": {"count": 0, "ports": [5060, 5061]},
        "RDP": {"count": 0, "ports": [3389]},
        "SSDP": {"count": 0, "ports": [1900]},
        "Other": {"count": 0, "ports": []}
    }

    # Initialize counters for IP versions and total packets
    ipv4_count = 0
    ipv6_count = 0
    total_packets = 0

    # Iterate over each packet in the pcap file
    for pkt in pcap_file:
        total_packets += 1

        # Layer 2 protocol detection
        if pkt.haslayer(Dot11):
            layer2_counts["Wi-Fi (802.11)"] += 1
        elif pkt.haslayer(Ether):
            eth_type = pkt[Ether].type
            if eth_type in [0x0800, 0x86DD]:
                layer2_counts["Ethernet (802.3)"] += 1
            elif eth_type == 0x0806:
                layer2_counts["ARP"] += 1
            elif eth_type == 0x8100:
                layer2_counts["VLAN"] += 1
            else:
                layer2_counts["Other"] += 1
        else:
            layer2_counts["Other"] += 1

        # Check for IPv4 vs IPv6 and Layer 3/4 protocols
        if pkt.haslayer(IP):
            ipv4_count += 1
            proto = pkt[IP].proto
            if proto == 1:
                protocol_counts["ICMP"] += 1
            elif proto == 6:
                protocol_counts["TCP"] += 1
            elif proto == 17:
                protocol_counts["UDP"] += 1
            else:
                protocol_counts["Other"] += 1
        elif pkt.haslayer(IPv6):
            ipv6_count += 1
            if pkt.haslayer("ICMPv6EchoRequest") or pkt.haslayer("ICMPv6EchoReply"):
                protocol_counts["ICMPv6"] += 1
            else:
                protocol_counts["Other"] += 1

        # Application Layer protocol detection using TCP/UDP ports
        ports = ()
        if pkt.haslayer(TCP):
            ports = (pkt[TCP].sport, pkt[TCP].dport)
        elif pkt.haslayer(UDP):
            ports = (pkt[UDP].sport, pkt[UDP].dport)

        # Match packet ports with known application protocols
        matched = False
        for proto, details in app_protocols.items():
            if any(p in ports for p in details["ports"]):
                app_protocols[proto]["count"] += 1
                matched = True
                break
        if not matched:
            app_protocols["Other"]["count"] += 1

    # Calculate totals for each layer
    total_layer2 = sum(layer2_counts.values())
    total_layer34 = sum(protocol_counts.values())
    total_app = sum(details["count"] for details in app_protocols.values())

    # Calculate IPv4/IPv6 percentages
    ipv4_pct = round((ipv4_count / total_packets) * 100, 2) if total_packets else 0
    ipv6_pct = round((ipv6_count / total_packets) * 100, 2) if total_packets else 0

    # Print total packets
    print(bcolors.CYAN + bcolors.BOLD + f"\nTotal Packets: {total_packets}" + bcolors.ENDC)

    # Print IPv4 vs IPv6 summary
    print(bcolors.CYAN + bcolors.BOLD + f"\nIPv4 vs IPv6:" + bcolors.ENDC)
    if ipv4_count > 0:
        print(bcolors.BLUE + bcolors.BOLD + f"IPv4: " + bcolors.ENDC +
              bcolors.BOLD + f"{ipv4_count} packets ({ipv4_pct}% of total)" + bcolors.ENDC)
    if ipv6_count > 0:
        print(bcolors.BLUE + bcolors.BOLD + f"IPv6: " + bcolors.ENDC +
              bcolors.BOLD + f"{ipv6_count} packets ({ipv6_pct}% of total)" + bcolors.ENDC)

    # Layer 2 Protocols output
    print(bcolors.CYAN + bcolors.BOLD + f"\nLayer 2 Protocols (Total: {total_layer2}):" + bcolors.ENDC)
    sorted_layer2 = sorted(layer2_counts.items(), key=lambda x: x[1], reverse=True)
    for proto, count in sorted_layer2:
        if count > 0:
            pct_layer = round((count / total_layer2) * 100, 2)
            pct_total = round((count / total_packets) * 100, 2)
            print(bcolors.BLUE + bcolors.BOLD + f"{proto:<25}: " + bcolors.ENDC +
                  bcolors.BOLD + f"{count} packets" + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + f" ({pct_layer}% of Layer 2)" + bcolors.ENDC)

    # Layer 3 & 4 Protocols output
    print(bcolors.CYAN + bcolors.BOLD + f"\nLayers 3 & 4 Protocols (Total: {total_layer34}):" + bcolors.ENDC)
    sorted_layer34 = sorted(protocol_counts.items(), key=lambda x: x[1], reverse=True)
    for proto, count in sorted_layer34:
        if count > 0:
            pct_layer = round((count / total_layer34) * 100, 2)
            pct_total = round((count / total_packets) * 100, 2)
            print(bcolors.BLUE + bcolors.BOLD + f"{proto:<25}: " + bcolors.ENDC +
                  bcolors.BOLD + f"{count} packets" + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + f" ({pct_layer}% of L3/4)" + bcolors.ENDC)

    # Application Layer Protocols output
    print(bcolors.CYAN + bcolors.BOLD + f"\nApplication Layer Protocols (Total: {total_app}):" + bcolors.ENDC)
    sorted_app = sorted(app_protocols.items(), key=lambda x: x[1]["count"], reverse=True)
    for proto, details in sorted_app:
        count = details["count"]
        if count > 0:
            pct_layer = round((count / total_app) * 100, 2)
            pct_total = round((count / total_packets) * 100, 2)
            ports_str = ", ".join(str(p) for p in details["ports"]) if details["ports"] else "-"
            print(bcolors.BLUE + bcolors.BOLD + f"{proto:<20} (ports: {ports_str}) : " + bcolors.ENDC +
                 bcolors.BOLD + f"{count} packets" + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD +  f" ({pct_layer}% of App Layer)" + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Run the main interactive menu loop
option_selected = ""
while (option_selected != -1):
    # Wait for user to press ENTER before displaying the menu
    input(bcolors.YELLOW + bcolors.BOLD + "\npress ENTER to display menu" + bcolors.ENDC)

    # Display available options for analysis and attack detection
    print()
    print(bcolors.BLUE + bcolors.BOLD + "1- Read packet by packet" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "2- Get protocols used in layers 2 & 3 & 4 & 7")
    print(bcolors.BLUE + bcolors.BOLD + "3- Analyze network statistics for a specific IP address" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "4- Gather IP & MAC addresses with MAC vendors" + bcolors.ENDC)
    print(
        bcolors.BLUE + bcolors.BOLD + "5- Gather all queried domain names with their correspoding answers and record types" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "6- Get all DHCP & DNS & Router IP addresses" + bcolors.ENDC)
    print(
        bcolors.BLUE + bcolors.BOLD + "7- Collect usernames & passwords from HTTP, FTP, Telnet, SMTP, POP3, IMAP traffic" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "8- Analyze traffic flow" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "9- Carve files (only works in Linux systems)" + bcolors.ENDC)
    print("-" * 60)
    print(bcolors.RED + bcolors.BOLD + "Attacks Detection" + bcolors.ENDC)
    print("-" * 60)
    print(bcolors.BLUE + bcolors.BOLD + "10- Detect MAC flooding attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "11- Detect MAC spoofing attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "12- Detect ARP spoofing attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "13- Detect FTP brute force attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "14- Detect rogue DHCP server attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "15- Detect DHCP starvation attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "16- Detect DNS poisoning attack" + bcolors.ENDC)
    print()

    # Ask user to select an option from the menu
    option_selected = int(
        input(bcolors.YELLOW + bcolors.BOLD + "Enter the number of option to perform (-1 to exit): " + bcolors.ENDC))

    # Match the selected option and execute corresponding function
    match option_selected:
        case 1:
            # Display each packet individually, allow user to move to next packet or exit
            for packet in pcap_file:
                packet.show()
                print(bcolors.YELLOW + bcolors.BOLD + "-" * 50, "Press ENTER to see the next packet",
                      "-" * 50 + bcolors.ENDC)
                print(bcolors.YELLOW + bcolors.BOLD + "-" * 99, "Input '-1' to exit", "-" * 15 + bcolors.ENDC)
                exit_flag = input()
                try:
                    if int(exit_flag) == -1:
                        break
                except:
                    continue
        case 2:
            # Analyze and display protocols used in the capture
            get_protocols_used()
        case 3:
            # Show network statistics for a specific IP address
            get_ip_address_info()
        case 4:
            # Extract IP addresses, MAC addresses, and NIC vendors
            extract_ips_macs(pcap_file)
        case 5:
            # Extract all queried domain names with answers and record types
            extract_domain_names(pcap_file)
        case 6:
            # Retrieve DHCP, DNS, and Router IP addresses
            get_dhcp_dns_router_addresses(pcap_file)
        case 7:
            # Collect usernames and passwords from common protocols
            get_all_usernames_passwords()
        case 8:
            # Analyze traffic flow patterns
            analyze_traffic_flow()
        case 9:
            # Carve files from the pcap (Linux only)
            carve_files_from_pcap()
        case 10:
            # Detect MAC flooding attacks
            detect_mac_flooding()
        case 11:
            # Detect MAC spoofing attacks
            detect_mac_spoofing()
        case 12:
            # Detect ARP spoofing attacks
            detect_arp_spoofing()
        case 13:
            # Detect FTP brute force attacks
            detect_ftp_brute_force()
        case 14:
            # Detect rogue DHCP servers
            detect_rogue_dhcp_servers()
        case 15:
            # Detect DHCP starvation attacks
            detect_dhcp_starvation()
        case 16:
            # Detect DNS poisoning attacks
            detect_dns_poisoning()

# ----------------------------------The End----------------------------------
