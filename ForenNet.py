import logging
logging.getLogger("scapy.runtime").setLevel(logging.ERROR)  # To hide warnings generated by Scapy
from scapy.all import *
from scapy.layers.dns import DNS, DNSQR, DNSRR
from scapy.layers.inet import IP, TCP, UDP
from scapy.layers.inet6 import IPv6, ICMPv6EchoRequest, ICMPv6EchoReply
from scapy.layers.l2 import ARP
from scapy.layers.l2 import Ether
from scapy.layers.dhcp import DHCP, BOOTP
from scapy.layers.dot11 import Dot11
import argparse
from tabulate import tabulate
import numpy as np
from mac_vendor_lookup import MacLookup
import shutil
import subprocess
import os
import re
import base64
import matplotlib.pyplot as plt
from datetime import datetime
import platform
# -------------------------------------------------------------------------------

# Defining color constants
class bcolors:
    PURPLE = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

record_types = {1: 'A', 28: 'AAAA', 18: 'AFSDB', 42: 'APL',
                257: 'CAA', 60: 'CDNSKEY', 59: 'CDS', 37: 'CERT',
                5: 'CNAME', 62: 'CSYNC', 49: 'DHCID', 32769: 'DLV',
                39: 'DNAME', 48: 'DNSKEY', 43: 'DS', 108: 'EUI48',
                109: 'EUI64', 13: 'HINFO', 55: 'HIP', 65: 'HTTPS',
                45: 'IPSECKEY', 25: 'KEY', 36: 'KX', 29: 'LOC', 15: 'MX',
                35: 'NAPTR', 2: 'NS', 47: 'NSEC', 50: 'NSEC3', 51: 'NSEC3PARAM',
                61: 'OPENPGPKEY', 12: 'PTR', 17: 'RP', 46: 'RRSIG', 24: 'SIG',
                53: 'SMIMEA', 6: 'SOA', 33: 'SRV', 44: 'SSHFP', 64: 'SVCB',
                32768: 'TA', 249: 'TKEY', 52: 'TLSA', 250: 'TSIG', 16: 'TXT',
                256: 'URI', 63: 'ZONEMD',
                255:'ALL', 252:'AXFR', 251:'IXFR', 41:'OPT'}

# Create arguments
parser = argparse.ArgumentParser(description='PCAP File Forensics')
parser.add_argument('-f', '--file', metavar='<file name>', type=str, help='Enter PCAP file name', required=True)  # Mandatory
args = parser.parse_args()


file_name = args.file  # Getting the PCAP file name
if not os.path.isfile(file_name):  # Checking if the file exists
    print(bcolors.RED + f"[-] '{file_name}' file does not exist." + bcolors.ENDC)
    sys.exit(-1)

# Reading the file
print(bcolors.GREEN + f"[+] Reading the PCAP file: {file_name}" + bcolors.ENDC)
pcap_file = rdpcap(file_name)

# -------------------------------------------------------------------------------
# -------------------------------------------------------------------------------

def carve_files_from_pcap():
    if platform.system() == "Linux":
        output_base = os.path.join(os.getcwd(), "carved_output")
        tcpflow_out = os.path.join(output_base, "tcpflow_output")
        foremost_out = os.path.join(output_base, "foremost_output")

        # Ensure clean directories
        for path in [tcpflow_out, foremost_out]:
            if os.path.exists(path):
                shutil.rmtree(path)
            os.makedirs(path)

        try:
            # Step 1: Reconstruct TCP streams from the PCAP file
            subprocess.run(["tcpflow", "-r", file_name, "-o", tcpflow_out], check=True)

            # Step 2: Use foremost to carve files from tcpflow output
            subprocess.run(f"foremost -i {tcpflow_out}/* -o {foremost_out}", shell=True, check=True)

            print(bcolors.GREEN + bcolors.BOLD + f"\n[+] Carving complete. Check: {foremost_out}" + bcolors.ENDC)

            # Step 3: Show audit.txt summary
            audit_path = os.path.join(foremost_out, "audit.txt")
            if os.path.exists(audit_path):
                print(bcolors.YELLOW + bcolors.BOLD + "\n[+] Foremost Summary (from audit.txt):" + bcolors.ENDC)
                print(bcolors.CYAN + "-" * 50 + bcolors.ENDC)

                carved = False
                with open(audit_path, 'r') as audit:
                    for line in audit:
                        if "files extracted" in line.lower():
                            carved = True
                            print("   " + line.strip())

                if not carved:
                    print(bcolors.RED + bcolors.BOLD + "[-] No files were carved" + bcolors.ENDC)
            else:
                print(bcolors.RED + bcolors.BOLD + "[!] audit.txt not found â€” carving might have failed or no files were found" + bcolors.ENDC)

        except subprocess.CalledProcessError as e:
            print(bcolors.RED + bcolors.BOLD + f"[!] Error during processing: {e}" + bcolors.ENDC)
    else:
        print(bcolors.RED + bcolors.BOLD + "File Carving is not supported on this operating system." + bcolors.ENDC)
# -------------------------------------------------------------------------------

def analyze_traffic_flow():
    flows = {}
    for packet in pcap_file:
        if IP in packet and (TCP in packet or UDP in packet):
            proto = "TCP" if TCP in packet else "UDP"
            src_ip = packet[IP].src
            dst_ip = packet[IP].dst
            src_port = packet[TCP].sport if TCP in packet else packet[UDP].sport
            dst_port = packet[TCP].dport if TCP in packet else packet[UDP].dport

            # Normalize to handle bi-directional flow
            if (src_ip, src_port) < (dst_ip, dst_port):
                flow_key = (proto, src_ip, dst_ip, src_port, dst_port)
            else:
                flow_key = (proto, dst_ip, src_ip, dst_port, src_port)

            if flow_key not in flows:
                flows[flow_key] = {
                    "packets": 0,
                    "bytes": 0,
                    "first_seen": float(packet.time),
                    "last_seen": float(packet.time)
                }

            flows[flow_key]["packets"] += 1
            flows[flow_key]["bytes"] += len(packet)
            flows[flow_key]["last_seen"] = packet.time

    print(bcolors.PURPLE + bcolors.BOLD + "\nTraffic Flow Analysis" + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + "-" * 120 + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"{'Proto':<6} {'Src IP':<15} {'Dst IP':<15} {'SPort':<6} {'DPort':<6} {'Packets':<8} {'Bytes':<10} {'First Seen':<20} {'Duration (s)'}" + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + "-" * 120 + bcolors.ENDC)

    for flow, stats in flows.items():
        proto, src_ip, dst_ip, sport, dport = flow
        first_seen = datetime.fromtimestamp(float(stats["first_seen"])).strftime('%Y-%m-%d %H:%M:%S')
        duration = round(stats["last_seen"] - stats["first_seen"], 2)
        print(
            bcolors.YELLOW + bcolors.BOLD + f"{proto:<6} " + bcolors.ENDC +
            bcolors.BOLD + f"{src_ip:<15} {dst_ip:<15} {sport:<6} {dport:<6} {stats['packets']:<8} {stats['bytes']:<10} {first_seen:<20} {duration}" + bcolors.ENDC
        )

    print(bcolors.YELLOW + bcolors.BOLD + f"\nTotal number of flows: {len(flows)}" + bcolors.ENDC)

# -------------------------------------------------------------------------------

def detect_dns_poisoning():
    print(bcolors.PURPLE + bcolors.BOLD + "DNS Cache Poisoning Attack\n" + bcolors.ENDC)

    whitelist_input = input(bcolors.BOLD + "[?] Enter whitelisted domain names separated by commas (Press ENTER to leave it blank): " + bcolors.ENDC)
    whitelisted_domains = set(domain.strip().lower() for domain in whitelist_input.split(",") if domain.strip())

    dns_records = {}
    suspected_domains = []
    total_dns = 0

    txid_guess_tracker = {}  # (domain, rtype, txid, ip_src, mac_src) -> list of (sport, timestamp)
    port_guess_tracker = {}  # (domain, rtype, sport, ip_src, mac_src) -> list of (txid, timestamp)
    bailiwick_violations = set()  # For method 3

    # Ask user for time window size in seconds
    try:
        window_size = float(input(bcolors.BOLD + "[?] Enter time window size in seconds (Default 10): " + bcolors.ENDC))
    except:
        window_size = 10  # default 10 seconds

    try:
        threshold = int(input(bcolors.BOLD + "[?] Enter number of guessing threshold (Default 5): " + bcolors.ENDC))
    except:
        threshold = 5

    # Process packets
    for packet in pcap_file[DNS]:
        if packet[DNS].qr == 1:
            dns = packet[DNS]
            if dns.qd is None or dns.an is None:
                continue

            domain = dns.qd.qname.decode(errors="ignore").strip('.').lower()
            total_dns += 1

            if domain in whitelisted_domains:
                continue

            ip_src = packet[IP].src if packet.haslayer(IP) else "unknown"
            mac_src = packet.src if packet.haslayer(Ether) else "unknown"
            pkt_time = packet.time  # capture timestamp

            # Method 1: Conflicting A Records
            if domain not in dns_records:
                dns_records[domain] = {"ips": set(), "sources": set()}

            for i in range(dns.ancount):
                rr = dns.an[i]
                if rr.type == 1:  # A record
                    ip = rr.rdata
                    dns_records[domain]["ips"].add(ip)
                    dns_records[domain]["sources"].add(f"{ip_src} / {mac_src}")

            if (len(dns_records[domain]["ips"]) > 1 and len(dns_records[domain]["sources"]) > 1 and domain not in suspected_domains):
                suspected_domains.append(domain)

            # Method 2: Excessive TXID/Port Guessing with time window
            txid = dns.id
            sport = packet[UDP].sport if packet.haslayer(UDP) else None

            for i in range(dns.ancount):
                rr = dns.an[i]
                rtype = rr.type  # Record type

                key1 = (domain, rtype, txid, ip_src, mac_src)
                key2 = (domain, rtype, sport, ip_src, mac_src)

                # --- Maintain rolling window for txid_guess_tracker ---
                if key1 not in txid_guess_tracker:
                    txid_guess_tracker[key1] = []
                # Keep only timestamps within the window
                txid_guess_tracker[key1] = [t for t in txid_guess_tracker[key1] if pkt_time - t[1] <= window_size]
                # Append new (sport, timestamp) always
                txid_guess_tracker[key1].append((sport, pkt_time))
                # Sort by time to keep order
                txid_guess_tracker[key1].sort(key=lambda x: x[1])

                # --- Maintain rolling window for port_guess_tracker ---
                if key2 not in port_guess_tracker:
                    port_guess_tracker[key2] = []
                port_guess_tracker[key2] = [t for t in port_guess_tracker[key2] if pkt_time - t[1] <= window_size]
                port_guess_tracker[key2].append((txid, pkt_time))
                port_guess_tracker[key2].sort(key=lambda x: x[1])

        # Method 3: Out-of-Bailiwick Responses
        if packet.haslayer(DNS) and packet[DNS].qr == 1:
            dns = packet[DNS]
            if dns.qd and dns.an:
                queried_domain = dns.qd.qname.decode(errors="ignore").strip('.').lower()
                q_parts = queried_domain.split(".")
                queried_root = ".".join(q_parts[-2:]) if len(q_parts) >= 2 else queried_domain

                # Skip processing if the queried domain is whitelisted (including subdomains)
                if any(queried_domain == d or queried_domain.endswith("." + d) for d in whitelisted_domains):
                    continue

                for i in range(dns.ancount):
                    rr = dns.an[i]
                    if rr.type == 1 or rr.type == 5:  # A or CNAME
                        answer_domain = rr.rrname.decode(errors="ignore").strip('.').lower()
                        a_parts = answer_domain.split(".")
                        answer_root = ".".join(a_parts[-2:]) if len(a_parts) >= 2 else answer_domain

                        # Skip processing if the answer domain is whitelisted (including subdomains)
                        if any(answer_domain == d or answer_domain.endswith("." + d) for d in whitelisted_domains):
                            continue

                        if queried_root != answer_root:
                            bailiwick_violations.add((queried_domain, answer_domain))

    # Output
    print(bcolors.YELLOW + f"[+] Total DNS responses analyzed: {total_dns}" + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + "\nSuspected DNS domain names:" + bcolors.ENDC)
    print("-" * 60)

    if suspected_domains:
        count = 1
        for domain in suspected_domains:
            print(bcolors.YELLOW + bcolors.BOLD + f"[{count}] [!] Domain: {domain}" + bcolors.ENDC)
            print(bcolors.YELLOW + bcolors.BOLD + f"    â†’ IPs: " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(dns_records[domain]['ips'])}" + bcolors.ENDC)
            print(bcolors.YELLOW + bcolors.BOLD + f"    â†’ Sources: " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(dns_records[domain]['sources'])}" + bcolors.ENDC)
            print(bcolors.CYAN + "-" * 60 + bcolors.ENDC)
            count += 1
        print(bcolors.RED + bcolors.BOLD + f"Total number of suspected domains: {len(suspected_domains)}" + bcolors.ENDC)
    else:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No conflicting A records from multiple sources detected" + bcolors.ENDC)

    # Method 2 Output - TXID / Port Guessing Detection
    count = 0
    print(bcolors.CYAN + bcolors.BOLD + "\n[!] DNS TXID / Port Guessing Detection" + bcolors.ENDC)
    # threshold = 3
    detected = False

    for (domain, rtype, port, ip_src, mac_src), txid_list in port_guess_tracker.items():
        unique_txids = sorted(set(t[0] for t in txid_list))
        if len(unique_txids) > threshold:
            detected = True
            count += 1
            rtype_name = record_types.get(rtype, f"TYPE{rtype}")
            print(bcolors.RED + bcolors.BOLD + f"{[count]}[!] TXID guessing detected"
                  + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + " â†’ Domain: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{domain}"
                  + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", Type: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{rtype_name}"
                  + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", Port: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{port}" + bcolors.ENDC)
            print(bcolors.YELLOW + bcolors.BOLD + f"    â†’ Source: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{ip_src} / {mac_src}"
                  + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", TXIDs: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{unique_txids}")

    for (domain, rtype, txid, ip_src, mac_src), port_list in txid_guess_tracker.items():
        unique_ports = sorted(set(t[0] for t in port_list))
        if len(unique_ports) > threshold:
            detected = True
            count += 1
            rtype_name = record_types.get(rtype, f"TYPE{rtype}")
            print(bcolors.RED + bcolors.BOLD + f"{[count]}[!] Port guessing detected" + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + " â†’ Domain: "
                   + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{domain}"
                   + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", Type: "
                   + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{rtype_name}"
                   + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", TXID: "
                   + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{txid}" + bcolors.ENDC)
            print(bcolors.YELLOW + bcolors.BOLD + f"    â†’ Source: " + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{ip_src} / {mac_src}"
                   + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + ", Ports: "
                   + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{unique_ports}")

    if not detected:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No excessive TXID or port guessing detected." + bcolors.ENDC)

    # Method 3 output: Out-of-Bailiwick Responses
    count = 0
    if bailiwick_violations:
        print(bcolors.CYAN + bcolors.BOLD + "\nOut-of-Bailiwick DNS Responses:" + bcolors.ENDC)
        for query, answer in bailiwick_violations:
            count += 1
            print(bcolors.YELLOW + bcolors.BOLD + f"{[count]} [!] Query: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{query}"
                  + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + "  -->  Answered by: "
                  + bcolors.ENDC + bcolors.RED + bcolors.BOLD + f"{answer}" + bcolors.ENDC)


# -------------------------------------------------------------------------------

# Detect DHCP Starvation
def detect_dhcp_starvation():
    print(bcolors.PURPLE + bcolors.BOLD + "DHCP Starvation Attack" + bcolors.ENDC)
    try:
        discover_limit = int(input(bcolors.BOLD + "[?] Enter DHCP Discover packet count threshold (default 100): " + bcolors.ENDC) or 100)
    except ValueError:
        discover_limit = 100

    try:
        mac_ratio = float(input(bcolors.BOLD + "[?] Enter unique MACs ratio threshold (0-1, default 0.2): " + bcolors.ENDC) or 0.2)
    except ValueError:
        mac_ratio = 0.9

    try:
        offer_ratio = float(input(bcolors.BOLD + "[?] Enter Offer/Discover ratio threshold (0-1, default 0.1): " + bcolors.ENDC) or 0.1)
    except ValueError:
        offer_ratio = 0.1
    print()

    discover_count = 0
    offer_count = 0
    discover_macs = set()

    for packet in pcap_file[DHCP]:
        msg_type = None
        for option in packet[DHCP].options:
            if isinstance(option, tuple) and option[0] == 'message-type':
                msg_type = option[1]
                break
        if msg_type is None:
            continue

        if msg_type == 1:  # Discover
            discover_count += 1
            if Ether in packet:
                discover_macs.add(packet[Ether].src)
        elif msg_type == 2:  # Offer
            offer_count += 1

    unique_macs = len(discover_macs)
    mac_unique_ratio = unique_macs / discover_count if discover_count else 0
    offer_discover_ratio = offer_count / discover_count if discover_count else 0

    print(bcolors.YELLOW + bcolors.BOLD + f"DHCP Discover count: {discover_count}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"Unique MAC addresses: {unique_macs}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"DHCP Offer count: {offer_count}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"Unique MAC ratio: {mac_unique_ratio:.2%}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"Offer/Discover ratio: {offer_discover_ratio:.2%}" + bcolors.ENDC)

    suspicious = (discover_count >= discover_limit
                  and mac_unique_ratio >= mac_ratio
                  and offer_discover_ratio <= offer_ratio)

    if suspicious:
        print(bcolors.RED + bcolors.BOLD + "[!] DHCP Starvation Attack detected" + bcolors.ENDC)
    else:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No DHCP Starvation Attack detected" + bcolors.ENDC)

# -------------------------------------------------------------------------------

def visualize_dhcp_server_responses(dhcp_servers, whitelist):
    servers = []
    counts = []
    colors = []

    for (ip, mac), data in dhcp_servers.items():
        servers.append(f"{ip}\n{mac}")
        counts.append(data['count'])
        if (ip, mac) in whitelist:
            colors.append('green')  # Whitelisted: green
        else:
            colors.append('red')  # Rogue: red

    plt.figure(figsize=(10, 6))
    bars = plt.bar(servers, counts, color=colors)

    plt.xlabel('DHCP Servers (IP and MAC)')
    plt.ylabel('Number of Responses Sent')
    plt.title('DHCP Servers Activity')

    # Add count labels on top of bars
    for bar in bars:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width() / 2, height, str(height), ha='center', va='bottom')

    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()
    plt.show()

# -------------------------------------------------------------------------------

# Detect Rogue DHCP Servers
def visualize_dhcp_servers(dhcp_servers, whitelist_ips, whitelist_macs):
    servers = []
    counts = []
    colors = []

    for (ip, mac), data in dhcp_servers.items():
        servers.append(f"{ip}\n{mac}")
        counts.append(data['count'])

        # Whitelist check for IP or MAC addresses
        if ip in whitelist_ips or mac.lower() in whitelist_macs:
            colors.append('green')
        else:
            colors.append('red')

    plt.figure(figsize=(10, 6))
    bars = plt.bar(servers, counts, color=colors)

    plt.xlabel('DHCP Servers (IP and MAC)')
    plt.ylabel('Number of Responses Sent')
    plt.title('DHCP Servers Activity')

    for bar in bars:
        height = bar.get_height()
        plt.text(bar.get_x() + bar.get_width() / 2, height, str(height), ha='center', va='bottom')

    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()
    plt.show()


def detect_rogue_dhcp_servers():
    whitelist_ips_input = input(bcolors.PURPLE + bcolors.BOLD +
                                "[?] Enter whitelist IPs (comma separated), or press Enter to skip: " +
                                bcolors.ENDC).strip()
    whitelist_macs_input = input(bcolors.PURPLE + bcolors.BOLD +
                                "[?] Enter whitelist MACs (comma separated), or press Enter to skip: " +
                                bcolors.ENDC).strip().lower()

    whitelist_ips = set(ip.strip() for ip in whitelist_ips_input.split(",")) if whitelist_ips_input else set()
    whitelist_macs = set(mac.strip() for mac in whitelist_macs_input.split(",")) if whitelist_macs_input else set()

    dhcp_servers = {}
    for packet in pcap_file[DHCP]:
        options = packet[DHCP].options
        msg_type = None
        router = None
        dns = None
        subnet = None

        for option in options:
            if isinstance(option, tuple):
                if option[0] == "message-type":
                    msg_type = option[1]
                elif option[0] == "router":
                    router = option[1]
                elif option[0] == "name_server":
                    dns = option[1]
                elif option[0] == "subnet_mask":
                    subnet = option[1]

        try:  # If Ether layer doesn't exist
            if msg_type == 2 or msg_type == 5:  # Offer or Ack
                server_ip = packet[IP].src
                server_mac = packet[Ether].src.lower()
                key = (server_ip, server_mac)

                if key not in dhcp_servers:
                    dhcp_servers[key] = {
                        "count": 1,
                        "routers": set(),
                        "dns": set(),
                        "subnets": set()
                    }
                else:
                    dhcp_servers[key]["count"] += 1

                if router:
                    if isinstance(router, list):
                        dhcp_servers[key]["routers"].update(router)
                    else:
                        dhcp_servers[key]["routers"].add(router)
                if dns:
                    if isinstance(dns, list):
                        dhcp_servers[key]["dns"].update(dns)
                    else:
                        dhcp_servers[key]["dns"].add(dns)
                if subnet:
                    dhcp_servers[key]["subnets"].add(subnet)
        except:
            continue

    print(bcolors.PURPLE + bcolors.BOLD + "\nRogue DHCP Server Detection" + bcolors.ENDC)
    print("-" * 90)

    rogue_count = 0
    for (ip, mac), data in dhcp_servers.items():
        if ip in whitelist_ips or mac in whitelist_macs:
            color = bcolors.GREEN + bcolors.BOLD
            status = "[+] Whitelisted Server"
        else:
            color = bcolors.RED + bcolors.BOLD
            status = "[!] Not in whitelist â†’ Possible Rogue Server"
            rogue_count += 1

        print(f"{color}Server IP: {ip}, MAC: {mac}" + bcolors.ENDC)
        print(bcolors.BOLD + f"  -> Responses Sent: {data['count']}" + bcolors.ENDC)
        print(bcolors.BOLD + f"  -> Routers Sent: {', '.join(data['routers']) if data['routers'] else 'N/A'}" + bcolors.ENDC)
        print(bcolors.BOLD + f"  -> DNS Sent: {', '.join(data['dns']) if data['dns'] else 'N/A'}" + bcolors.ENDC)
        print(bcolors.BOLD + f"  -> Subnets Sent: {', '.join(data['subnets']) if data['subnets'] else 'N/A'}" + bcolors.ENDC)
        print(f"{color}  {status}" + bcolors.ENDC)
        print("-" * 90)

    if rogue_count > 0:
        print(bcolors.RED + bcolors.BOLD + f"[!] {rogue_count} Rogue DHCP server(s) detected." + bcolors.ENDC)
    else:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No Rogue DHCP servers detected." + bcolors.ENDC)

    visualize_dhcp_servers(dhcp_servers, whitelist_ips, whitelist_macs)

# -------------------------------------------------------------------------------

# Detect FTP Brute Force
def detect_ftp_brute_force():
    print(bcolors.PURPLE + bcolors.BOLD + "FTP Brute Force Attack:" + bcolors.ENDC)
    failure_threshold = int(input(bcolors.BOLD + "[?] Enter failures threshold: " + bcolors.ENDC))
    time_window = float(input(bcolors.BOLD + "[?] Enter time window in seconds: " + bcolors.ENDC))
    attempts = {}
    failures = {}
    credentials = {}

    for packet in pcap_file:
        if packet.haslayer(IP) and packet.haslayer(TCP):
            ip_src = packet[IP].src
            ip_dst = packet[IP].dst
            sport = packet[TCP].sport
            dport = packet[TCP].dport

            # Detect login requests
            if dport == 21 and packet.haslayer(Raw): # Raw included to prevent counting ACK messages from the server and initial messages from the client - they don't have Ram layer
                payload = packet[Raw].load.decode(errors="ignore").strip()

                # Collect entered credentials
                if payload.upper().startswith("USER") or payload.upper().startswith("PASS"):
                    if ip_src not in credentials:
                        credentials[ip_src] = []
                    credentials[ip_src].append(payload)

                    # Count Attempts
                    if ip_src in attempts:
                        attempts[ip_src] += 1
                    else:
                        attempts[ip_src] = 1

            # FTP Response Codes -> 530 User cannot log in | 331 Password Required | 230 User logged in
            # Detect the error messages from the FTP server
            elif sport == 21 and packet.haslayer(Raw):
                try:
                    payload = packet[Raw].load.decode(errors="ignore")
                    if "530" in payload or "User cannot log in" in payload or "Incorrect password" in payload or "Not logged in" in payload:
                        ip = ip_dst  # client IP (who attempted login)
                        timestamp = datetime.fromtimestamp(float(packet.time))

                        if ip not in failures:
                            failures[ip] = []
                        failures[ip].append(timestamp)
                except:
                    continue

    # Create a table
    print(bcolors.YELLOW + bcolors.BOLD + "\n[!] Suspicious IPs with high FTP login failures:" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + "-" * 60 + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + f"{'IP Address':<20} {'Attempts':<10} {'Failures':<10}" + bcolors.ENDC)
    print(bcolors.BOLD + "-" * 60 + bcolors.ENDC)

    suspicious_ips = []
    for ip in failures:
        timestamps = sorted(set(failures[ip]))  # Remove duplicates
        for i in range(len(timestamps)):
            count = 1
            start_time = timestamps[i]
            for j in range(i + 1, len(timestamps)):
                delta = (timestamps[j] - start_time).total_seconds()
                if delta <= time_window:
                    count += 1
                else:
                    break
            if count >= failure_threshold:
                suspicious_ips.append(ip)
                total_attempts = attempts.get(ip, 0)
                print(bcolors.YELLOW + bcolors.BOLD + f"{ip:<20}" + bcolors.ENDC +
                      bcolors.RED + bcolors.BOLD + f" {total_attempts // 2:<10} {count:<10}" + bcolors.ENDC)
                break  # stop checking further windows for this IP

    if not suspicious_ips:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No FTP brute force attack detected." + bcolors.ENDC)
    else:
        print(bcolors.CYAN + bcolors.BOLD + "\nEntered Credentials from Suspicious IPs:" + bcolors.ENDC)
        print(bcolors.BOLD + "-" * 60 + bcolors.ENDC)
        for ip in suspicious_ips:
            creds = credentials.get(ip, [])
            if creds:
                print(bcolors.YELLOW + bcolors.BOLD + f"\n-> {ip}:" + bcolors.ENDC)
                for line in creds:
                    print(bcolors.RED + bcolors.BOLD + f"    â†’ {line}" + bcolors.ENDC)
            else:
                print(bcolors.GREEN + bcolors.BOLD + f"\n[+] {ip}: No credentials captured." + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Detect MAC Spoofing
def detect_mac_spoofing():
    mac_to_ips = {}

    for pkt in pcap_file:
        if pkt.haslayer(Ether) and pkt.haslayer(IP):
            ip = pkt[IP].src.strip()
            mac = pkt[Ether].src.lower()

            if mac not in mac_to_ips:
                mac_to_ips[mac] = [ip]
            elif ip not in mac_to_ips[mac]:
                mac_to_ips[mac].append(ip)

    # Print MAC Spoofing results (MAC mapped to multiple IPs)
    print(bcolors.PURPLE + bcolors.BOLD + "MAC Spoofing Attack\n" + bcolors.ENDC)
    mac_spoofing_found = False
    for mac, ips in mac_to_ips.items():
        if len(ips) > 1:
            mac_spoofing_found = True
            print(bcolors.RED + bcolors.BOLD + "[!] MAC Address" + bcolors.ENDC +
                  bcolors.RED + bcolors.BOLD + f" {mac}" + bcolors.ENDC +
                  bcolors.YELLOW + f" is associated with multiple IP addresses: " + bcolors.ENDC +
                  bcolors.BOLD + f"{', '.join(ips)}" + bcolors.ENDC)
    if not mac_spoofing_found:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No MAC Spoofing attack detected" + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Detect MAC Flooding
def detect_mac_flooding():
    print(bcolors.PURPLE + bcolors.BOLD + "MAC Flooding Detection per Time Window\n" + bcolors.ENDC)
    # Get user inputs with validation
    while True:
        try:
            window_size = int(input(bcolors.BOLD + "Enter time window size in seconds: " + bcolors.ENDC))
            if window_size <= 0:
                print(bcolors.RED + bcolors.BOLD + "Please enter a positive integer for window size: " + bcolors.ENDC)
                continue
            break
        except:
            print(bcolors.RED + bcolors.BOLD + "Invalid input! Please enter a valid integer for window size: " + bcolors.ENDC)

    while True:
        try:
            mac_threshold = int(input(bcolors.BOLD + "Enter threshold for unique MAC addresses: " + bcolors.ENDC))
            if mac_threshold <= 0:
                print(bcolors.RED + bcolors.BOLD + "Please enter a positive integer for MAC threshold: " + bcolors.ENDC)
                continue
            break
        except:
            print(bcolors.RED + bcolors.BOLD + "Invalid input! Please enter a valid integer for MAC threshold: " + bcolors.ENDC)

    start_time = pcap_file[0].time
    macs_per_window = {}

    for packet in pcap_file:
        if packet.haslayer(Ether):
            current_time = packet.time
            window_idx = int((current_time - start_time) // window_size)
            if window_idx not in macs_per_window:
                macs_per_window[window_idx] = []
            macs_per_window[window_idx].append(packet[Ether].src)

    flagged_windows = 0

    print(bcolors.CYAN + bcolors.BOLD + f"\n{'Window #':<10} {'Time Range (s)':<20} {'Unique MACs':<12} {'Status'}" + bcolors.ENDC)
    print(bcolors.CYAN + "-" * 60 + bcolors.ENDC)

    for window_idx in sorted(macs_per_window.keys()):
        mac_list = macs_per_window[window_idx]
        unique_macs_count = len(set(mac_list))
        time_range = bcolors.BOLD + f"{window_idx * window_size} - {(window_idx + 1) * window_size}"
        status = ""
        if unique_macs_count > mac_threshold:
            flagged_windows += 1
            status = bcolors.RED + bcolors.BOLD + "[! Suspicious]" + bcolors.ENDC
        else:
            status = bcolors.GREEN + bcolors.BOLD + "Normal" + bcolors.ENDC

        print(bcolors.BOLD + f"{window_idx:<10} {time_range:<24} {unique_macs_count:<12} {status}")

    if flagged_windows == 0:
        print(bcolors.GREEN + bcolors.BOLD + "\n[-] No MAC flooding detected per time window." + bcolors.ENDC)
    else:
        print(
            bcolors.RED + bcolors.BOLD + f"\n[!] Suspicious MAC flooding detected in {flagged_windows} time window(s)." + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Detect ARP spoofing
def detect_arp_spoofing():
    print("\n" + bcolors.PURPLE + bcolors.BOLD + "ARP Spoofing Detection" + bcolors.ENDC)

    # Step 1: Build trusted map from IP traffic
    trusted_ip_mac = {}

    for packet in pcap_file:
        if packet.haslayer(Ether) and packet.haslayer(IP):
            ip = packet[IP].src
            mac = packet[Ether].src.lower()
            if ip not in trusted_ip_mac:
                trusted_ip_mac[ip] = mac

    # Step 2: Check ARP packets (both requests and replies)
    detected = False
    reported = set()

    for packet in pcap_file:
        if packet.haslayer(ARP):
            arp_layer = packet[ARP]
            claimed_ip = arp_layer.psrc
            claimed_mac = arp_layer.hwsrc.lower()
            arp_type = "Request" if arp_layer.op == 1 else "Reply"

            if claimed_ip in trusted_ip_mac:
                real_mac = trusted_ip_mac[claimed_ip]
                if claimed_mac != real_mac:
                    key = (claimed_ip, claimed_mac, arp_layer.op)
                    if key not in reported:
                        reported.add(key)
                        detected = True
                        print(bcolors.RED + bcolors.BOLD + f"[!] ARP Spoofing Detected ({arp_type})" + bcolors.ENDC)
                        print(bcolors.YELLOW + bcolors.BOLD + f"    Claimed IP : {claimed_ip}" + bcolors.ENDC)
                        print(bcolors.YELLOW + bcolors.BOLD + f"    MAC in ARP : {claimed_mac}" + bcolors.ENDC)
                        print(bcolors.BLUE + bcolors.BOLD + f"    Real MAC   : {real_mac}" + bcolors.ENDC)
                        print(bcolors.YELLOW + "-" * 50 + bcolors.ENDC)

    if not detected:
        print(bcolors.GREEN + bcolors.BOLD + "[+] No ARP Spoofing attack detected" + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Get all usernames & passwords
def get_all_usernames_passwords():
    print(bcolors.PURPLE + bcolors.BOLD + "Captured Credentials from HTTP, FTP, Telnet, POP3, SMTP, IMAP\n" + bcolors.ENDC)
    credentials = {
        "HTTP": [],
        "FTP": [],
        "Telnet": [],
        "POP3": [],
        "SMTP": [],
        "IMAP": []
    }
    stats = {k: 0 for k in credentials}

    pop3_state = {}  # session (ip_src, ip_dst) â†’ {"user": ...}
    char_buffer = {}  # To buffer single character from Telnet traffic
    telnet_cred_found = False
    telnet_state = None  # To track Telnet state if it detects requests for username or password
    print_telnet_welcome = True

    for packet in pcap_file:
        if not packet.haslayer(Raw):
            continue
        try:
            payload = packet[Raw].load.decode(errors="ignore")
        except:
            continue
        ip = packet[IP].src if packet.haslayer(IP) else "Unknown"

        # HTTP Basic Auth
        if "Authorization: Basic" in payload:
            m = re.search(r"Authorization: Basic ([A-Za-z0-9+/=]+)", payload)
            if m:
                b64 = m.group(1)
                try:
                    decoded = base64.b64decode(b64).decode(errors="ignore")
                    credentials["HTTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ Basic Auth: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{decoded}" + bcolors.ENDC)
                except:
                    credentials["HTTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ Basic Auth (Invalid): " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{b64}" + bcolors.ENDC)
                stats["HTTP"] += 1

        # HTTP POST Form
        if "POST" in payload and "log=" in payload and "pwd=" in payload:
            u = re.search(r"log=([^&]+)", payload)
            p = re.search(r"pwd=([^&]+)", payload)
            if u and p:
                credentials["HTTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ POST user: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{u.group(1)}" + bcolors.ENDC)
                credentials["HTTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ POST pass: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{p.group(1)}" + bcolors.ENDC)
                stats["HTTP"] += 2

        # FTP
        if "USER " in payload:
            username = payload.split("USER ")[1].split("\r")[0]
            credentials["FTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ USER: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{username}" + bcolors.ENDC)
            stats["FTP"] += 1
        if "PASS " in payload:
            password = payload.split("PASS ")[1].split("\r")[0]
            credentials["FTP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ PASS: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{password}" + bcolors.ENDC)
            stats["FTP"] += 1

        # POP3
        if packet.haslayer(TCP) and (packet[TCP].dport == 110 or packet[TCP].sport == 110):
            session = (packet[IP].src, packet[IP].dst) if packet.haslayer(IP) else "Unknown"
            if session not in pop3_state:
                pop3_state[session] = {"user": None}

            lines = payload.strip().splitlines()
            for line in lines:
                if line.upper().startswith("USER "):
                    username = line[5:].strip()
                    pop3_state[session]["user"] = username
                elif line.upper().startswith("PASS "):
                    password = line[5:].strip()
                    username = pop3_state[session].get("user", "")
                    entry = bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ USER: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{username}" \
                            + bcolors.ENDC + bcolors.BLUE + bcolors.BOLD + " / PASS: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{password}" + bcolors.ENDC
                    if entry not in credentials["POP3"]:
                        credentials["POP3"].append(entry)
                        stats["POP3"] += 1
                    pop3_state[session]["user"] = None  # clear after use

        # IMAP LOGIN
        if packet.haslayer(TCP) and packet[TCP].dport == 143 and "LOGIN" in payload.upper():
            parts = payload.strip().split()
            if len(parts) >= 3:
                u, p = parts[-2], parts[-1]
                credentials["IMAP"].append(bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ LOGIN: "
                                           + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{u}"
                                           + bcolors.ENDC + bcolors.BLUE + bcolors.BOLD + " / "
                                           + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{p}")
                stats["IMAP"] += 1

        # Telnet
        IAC = 255
        SE = 240
        SB = 250

        if packet.haslayer(TCP) and packet.haslayer(IP):
            tcp = packet[TCP]
            ip_src = packet[IP].src
            ip_dst = packet[IP].dst

            if tcp.sport == 23 or tcp.dport == 23:
                raw_bytes = bytes(packet[Raw].load)

                # Strip Telnet control messages (IAC commands and subnegotiation)
                result = bytearray()
                i = 0
                while i < len(raw_bytes):
                    if raw_bytes[i] == IAC:
                        if i + 1 < len(raw_bytes):
                            command = raw_bytes[i + 1]

                            # Subnegotiation block: IAC SB ... IAC SE
                            if command == SB:
                                # Find end of subnegotiation
                                end = raw_bytes.find(bytes([IAC, SE]), i + 2)
                                if end != -1:
                                    i = end + 2
                                else:
                                    break  # malformed, stop parsing
                            # Standard 3-byte IAC command
                            elif i + 2 < len(raw_bytes):
                                i += 3
                            else:
                                break
                    else:
                        result.append(raw_bytes[i])
                        i += 1

                # Decode cleaned payload
                try:
                    telnet_payload = result.decode('utf-8', errors='replace')
                except:
                    telnet_payload = "<decode error>"

                # Identify session
                session = (ip_src, ip_dst) if tcp.dport == 23 else (ip_dst, ip_src)

                # Server
                if tcp.sport == 23:  # and check_server:
                    if ("login:" in telnet_payload.lower() or "username:" in telnet_payload.lower()) and "last login:" not in telnet_payload.lower():
                        telnet_state = "waiting_username"
                    elif "password:" in telnet_payload.lower():
                        telnet_state = "waiting_password"

                # Client
                elif tcp.dport == 23 and (telnet_state == "waiting_username" or telnet_state == "waiting_password"):
                    if session not in char_buffer:
                        char_buffer[session] = ""

                    if len(telnet_payload) == 1 and telnet_payload.isprintable():
                        char_buffer[session] += telnet_payload

                    elif len(telnet_payload) > 1 and any(c.isprintable() for c in telnet_payload):
                        if char_buffer[session]:
                            if print_telnet_welcome:
                                print(bcolors.PURPLE + bcolors.BOLD + "[Telnet] Credentials:" + bcolors.ENDC)
                                print_telnet_welcome = False
                            print(bcolors.BLUE + bcolors.BOLD + f"[Client â†’ Server] {ip_src}:{tcp.sport} â†’ {ip_dst}:{tcp.dport}" + bcolors.ENDC)
                            if telnet_state == "waiting_username":
                                print(bcolors.YELLOW + bcolors.BOLD + f"Username: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{repr(char_buffer[session])}" + bcolors.ENDC)
                            elif telnet_state == "waiting_password":
                                print(bcolors.YELLOW + bcolors.BOLD + f"Password: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{repr(char_buffer[session])}" + bcolors.ENDC)
                            char_buffer[session] = ""
                            stats["Telnet"] += 1

                    if '\r' in payload or '\n' in payload:
                        if char_buffer[session]:
                            if print_telnet_welcome:
                                print(bcolors.PURPLE + bcolors.BOLD + "[Telnet] Credentials:" + bcolors.ENDC)
                                print_telnet_welcome = False
                            print(bcolors.BLUE + bcolors.BOLD + f"[Client â†’ Server] {ip_src}:{tcp.sport} â†’ {ip_dst}:{tcp.dport}")
                            if telnet_state == "waiting_username":
                                print(bcolors.YELLOW + bcolors.BOLD + f"Username: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{repr(char_buffer[session])}" + bcolors.ENDC)
                            elif telnet_state == "waiting_password":
                                print(bcolors.YELLOW + bcolors.BOLD + f"Password: " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{repr(char_buffer[session])}" + bcolors.ENDC)
                            char_buffer[session] = ""
                            stats["Telnet"] += 1
                            if not telnet_cred_found:
                                telnet_cred_found = True
                            telnet_state = None

        # Base64-encoded AUTH detection for POP3 or SMTP based on port (independent)
        if packet.haslayer(TCP) and packet.haslayer(Raw):
            tcp = packet[TCP]
            dport = tcp.dport
            sport = tcp.sport

            try:
                payload_str = packet[Raw].load.decode(errors="ignore").strip()
            except:
                continue

            # Only attempt decoding on meaningful payloads
            if "AUTH LOGIN" in payload_str or re.fullmatch(r"[A-Za-z0-9+/=]{6,}", payload_str):
                # Only decode strings that are properly padded
                b64_input = payload_str.strip()
                if len(b64_input) % 4 != 0:
                    continue  # not a valid base64 block

                try:
                    decoded = base64.b64decode(b64_input).decode(errors="ignore").strip()
                except:
                    continue  # decoding failed

                # Discard non-printable or meaningless values
                if not decoded or not decoded.isprintable() or len(decoded) < 3:
                    continue

                # Get proper IP
                ip = packet[IP].src if packet.haslayer(IP) else "Unknown"
                entry = bcolors.BLUE + bcolors.BOLD + f"{ip} â†’ AUTH (Base64): " + bcolors.ENDC + bcolors.GREEN + bcolors.BOLD + f"{decoded}"

                if dport in [110] or sport in [110]:  # POP3
                    if entry not in credentials["POP3"]:
                        credentials["POP3"].append(entry)
                        stats["POP3"] += 1
                elif dport in [25, 465, 587] or sport in [25, 465, 587]:  # SMTP
                    if entry not in credentials["SMTP"]:
                        credentials["SMTP"].append(entry)
                        stats["SMTP"] += 1
                else:
                    # unknown port â†’ assume SMTP
                    if entry not in credentials["SMTP"]:
                        credentials["SMTP"].append(entry)
                        stats["SMTP"] += 1

    # Print results
    if telnet_cred_found:
        print(bcolors.GREEN + bcolors.BOLD + "\n[+] Credentials for Telnet found")
    else:
        print(bcolors.RED + bcolors.BOLD + "\n[-] No credentials found for Telnet")

    for proto, entries in credentials.items():
        if entries:
            print(bcolors.PURPLE + bcolors.BOLD + f"\n[{proto}] Credentials:" + bcolors.ENDC)
            for line in entries:
                print(bcolors.GREEN + bcolors.BOLD + line + bcolors.ENDC)

    found = False
    print(bcolors.PURPLE + bcolors.BOLD + "\nCredential Summary per Protocol:" + bcolors.ENDC)
    for proto in stats:
        print(bcolors.BOLD + f"{proto:<12}: {stats[proto]} entries" + bcolors.ENDC)
        if stats[proto] > 0 and proto != "Telnet":
            found = True

    if not found:
        print(bcolors.RED + bcolors.BOLD + "\n[-] No credentials found for HTTP, FTP, POP3, SMTP, IMAP" + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Get information about an IP address
def get_ip_address_info():
    specified_ip = input(bcolors.YELLOW + bcolors.BOLD + "Enter the target IP address: " + bcolors.ENDC)
    count = 0  # Number of packets sent from specified IP
    protocols = set()  # Protocol used
    dst_ip_addresses = set()  # Destination IPs contacted
    mac_src_addresses = set()  # Source MAC addresses
    mac_dst_addresses = set()  # Destination MAC addresses
    tcp_port_numbers = set()  # TCP destination ports
    udp_port_numbers = set()  # UDP destination ports

    dst_ip_count = {}  # Count of how many times each destination IP was contacted
    packet_sizes = []  # List to store size of each relevant packet
    timestamps = []  # List to store timestamp of each relevant packet

    for packet in pcap_file:
        try:
            if not packet.haslayer(Ether):  # Skip if no Ethernet layer
                continue

            if packet.haslayer(IP):  # Process only IP packets
                ip_layer = packet[IP]

                if ip_layer.src == specified_ip:  # Only packets from the specified source IP
                    count += 1  # Increment packet count

                    dst_ip = ip_layer.dst
                    dst_ip_addresses.add(dst_ip)  # Track unique destination IPs

                    # Count how many times each destination IP appears
                    dst_ip_count[dst_ip] = dst_ip_count.get(dst_ip, 0) + 1

                    mac_src_addresses.add(packet[Ether].src)  # Track unique source MAC addresses
                    mac_dst_addresses.add(packet[Ether].dst)  # Track unique destination MAC addresses

                    # Add TCP or UDP destination ports if present
                    if packet.haslayer(TCP):
                        tcp_port_numbers.add(packet[TCP].dport)
                    elif packet.haslayer(UDP):
                        udp_port_numbers.add(packet[UDP].dport)

                    packet_sizes.append(len(packet))  # Store packet size
                    timestamps.append(packet.time)  # Store packet timestamp

                    # Collect protocol layers except 'Raw' and 'Padding'
                    for layer in packet.layers():
                        name = str(layer).split(".")[-1].replace("'", "").replace(">", "")
                        if name not in ["Raw", "Padding"]:
                            protocols.add(name)
        except:
            continue

    total = len(pcap_file)  # Total number of packets in PCAP

    # Determine the most contacted destination IP or 'N/A' if none
    most_contacted_ip = max(dst_ip_count, key=dst_ip_count.get) if dst_ip_count else "N/A"
    # Calculate average packet size or 0 if no packets
    avg_packet_size = round(sum(packet_sizes) / len(packet_sizes), 2) if packet_sizes else 0
    # Sort timestamps to ensure correct order
    timestamps.sort()
    # Calculate duration of traffic or 0 if insufficient data
    duration = timestamps[-1] - timestamps[0] if len(timestamps) > 1 else 0
    # Calculate packets per second or 0 if duration is zero
    pps = round(count / duration, 2) if duration > 0 else 0

    # Output
    print(bcolors.PURPLE + bcolors.BOLD + bcolors.BOLD + f"IP Address Statistics: " + bcolors.ENDC + bcolors.BOLD + f"{specified_ip}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Sent Packets: " + bcolors.ENDC + bcolors.BOLD + f"{count}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Percentage of all packets: " + bcolors.ENDC + bcolors.BOLD + f"{round(count / total * 100, 2)}%" + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + f"\n[+] Destination IPs: " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(dst_ip_addresses)}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Most Frequent Destination: " + bcolors.ENDC + bcolors.BOLD + f"{most_contacted_ip}" + bcolors.ENDC)
    print(bcolors.CYAN + bcolors.BOLD + f"\n[+] Protocols Used ({len(protocols)}): " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(sorted(protocols))}" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + f"\n[+] Source MAC Addresses: " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(mac_src_addresses)}" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + f"\n[+] Destination MAC Addresses: " + bcolors.ENDC + bcolors.BOLD + f"{', '.join(mac_dst_addresses)}" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + f"\n[+] TCP Ports: " + bcolors.ENDC + bcolors.BOLD + f"{sorted(tcp_port_numbers) if tcp_port_numbers else 'None'}" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + f"\n[+] UDP Ports: " + bcolors.ENDC + bcolors.BOLD + f"{sorted(udp_port_numbers) if udp_port_numbers else 'None'}" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Average Packet Size: " + bcolors.ENDC + bcolors.BOLD + f"{avg_packet_size} bytes" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Traffic Duration: " + bcolors.ENDC + bcolors.BOLD + f"{round(duration, 2)} seconds" + bcolors.ENDC)
    print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Packet Rate: " + bcolors.ENDC + bcolors.BOLD + f"{pps} packets/sec" + bcolors.ENDC)

# -------------------------------------------------------------------------------

# Gather all IP addresses
def extract_ips_macs(pcap_file):
    addresses = {'IP Address':[], 'MAC Address':[], 'NIC Vendor':[]}
    mac_vendors = {}
    for packet in pcap_file:
        if(packet.haslayer(IP) and packet.haslayer(Ether)):
            if(packet[IP].src not in addresses['IP Address']):
                addresses['IP Address'].append(packet[IP].src)
                addresses['MAC Address'].append(packet[Ether].src)
                if(packet[Ether].src[:8] in mac_vendors):
                    addresses['NIC Vendor'].append(mac_vendors[packet[Ether].src[:8]])
                else:
                    try:
                        temp_mac_vendor = MacLookup().lookup(packet[Ether].src[:8])
                    except:
                        temp_mac_vendor = "Not Found"
                    addresses['NIC Vendor'].append(temp_mac_vendor)
                    mac_vendors[packet[Ether].src[:8]] = temp_mac_vendor
    # Print a table of 3 columns: IP Address - MAC Address - NIC Vendor
    print(tabulate(addresses, headers="keys", tablefmt="fancy_grid"))

    print("-" * 150)

    # Show NIC Vendors
    mac_vendors_set = set(list(mac_vendors.values()))
    list_for_numpy = [[vendor] for vendor in mac_vendors_set if vendor != "Not Found"]
    print(tabulate(np.array(list_for_numpy).reshape(len(list_for_numpy),1), headers=['NIC Vendors'], tablefmt="fancy_grid"))

# -------------------------------------------------------------------------------

# Gather all domain names
def extract_domain_names(pcap_file):
    domain_names = {"No.": [], "ID": [], "Query": [], "Response": [], "Record Type": []}

    seen = set()  # To track unique (Query, Response) pairs
    count = 0

    for packet in pcap_file:
        if packet.haslayer(DNSQR) and packet.haslayer(DNSRR):
            query = packet[DNSQR].qname.decode(errors="ignore").strip(".")
            qtype = packet[DNSQR].qtype
            dns_id = packet[DNS].id

            # Extract response data
            if packet[DNSRR].rdata:
                try:
                    if isinstance(packet[DNSRR].rdata, bytes):
                        response = packet[DNSRR].rdata.decode(errors="ignore").strip(".")
                    else:
                        response = str(packet[DNSRR].rdata).strip(".")
                except:
                    response = "-"
            else:
                response = "-"

            # Skip duplicate query-response pairs
            pair = (query, response)
            if pair in seen:
                continue
            seen.add(pair)

            # Save valid unique record
            count += 1
            domain_names["No."].append(count)
            domain_names["ID"].append(dns_id)
            domain_names["Query"].append(query)
            domain_names["Response"].append(response)
            domain_names["Record Type"].append(record_types.get(qtype, f"Type {qtype}"))

    # Display result as a fancy table
    print(tabulate(domain_names, headers="keys", tablefmt="fancy_grid"))

# ----------------------------------------------------------------------------------------

def get_dhcp_dns_router_addresses(pcap_file):
    print(bcolors.PURPLE + bcolors.BOLD + "Get DHCP & DNS & Router IP Addresses" + bcolors.ENDC)
    dhcp_ip_addresses = set()
    dns_ip_addresses = set()
    router_ip_addresses = set()

    for packet in pcap_file:
        if packet.haslayer(DHCP) or packet.haslayer(BOOTP):
            if packet[BOOTP].op == 2:  # Server's message response code is 2 (DHCP or ACK) -> op = 2
                options = packet[DHCP].options
                for opt in options:
                    try:
                        if isinstance(opt, tuple):
                            key, value = opt[0], opt[1]
                            if key == "server_id":
                                dhcp_ip_addresses.add(value)
                            elif key == "name_server":
                                if isinstance(value, list):
                                    for dns in value:
                                        dns_ip_addresses.add(dns)
                                else:
                                    dns_ip_addresses.add(value)
                            elif key == "router":
                                if isinstance(value, list):
                                    for router in value:
                                        router_ip_addresses.add(router)
                                else:
                                    router_ip_addresses.add(value)
                    except:
                        continue

    # Print results
    if dns_ip_addresses:
        print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] DHCP Server IP Addresses - {len(dns_ip_addresses)}" + bcolors.ENDC)
        count = 1
        for ip in dhcp_ip_addresses:
            print(bcolors.BOLD + f" {count}- {ip}" + bcolors.ENDC)
            count += 1
    else:
        print(bcolors.RED + bcolors.BOLD + f"\n[-] No DHCP Server IP addresses detected" + bcolors.ENDC)


    if dhcp_ip_addresses:
        print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] DNS Server IP Addresses - {len(dhcp_ip_addresses)}" + bcolors.ENDC)
        count = 1
        for ip in dns_ip_addresses:
            print(bcolors.BOLD + f" {count}- {ip}" + bcolors.ENDC)
            count += 1
    else:
        print(
            bcolors.RED + bcolors.BOLD + f"\n[-] No DNS Server IP addresses detected" + bcolors.ENDC)

    if router_ip_addresses:
        print(bcolors.YELLOW + bcolors.BOLD + f"\n[+] Router IP Addresses - {len(router_ip_addresses)}" + bcolors.ENDC)
        count = 1
        for ip in router_ip_addresses:
            print(bcolors.BOLD + f" {count}- {ip}" + bcolors.ENDC)
            count += 1
    else:
        print(bcolors.RED + bcolors.BOLD + f"\n[-] No Router IP addresses detected" + bcolors.ENDC)

# -------------------------------------------------------------------------------

def get_protocols_used():
    print(bcolors.PURPLE + bcolors.BOLD + "\nProtocol Analysis:" + bcolors.ENDC)

    # Layer 2 protocols
    layer2_counts = {
        "Wi-Fi (802.11)": 0,
        "Ethernet (802.3)": 0,
        "ARP": 0,
        "VLAN": 0,
        "Other": 0
    }

    # Layer 3 & 4 protocols
    protocol_counts = {
        "TCP": 0,
        "UDP": 0,
        "ICMP": 0,
        "ICMPv6": 0,
        "Other": 0
    }

    # Application Layer protocols
    app_protocols = {
        "HTTP": {"count": 0, "ports": [80]},
        "HTTPS": {"count": 0, "ports": [443]},
        "QUIC": {"count": 0, "ports": [443]},
        "FTP": {"count": 0, "ports": [20, 21]},
        "DNS": {"count": 0, "ports": [53]},
        "SMTP": {"count": 0, "ports": [25, 587]},
        "SSH": {"count": 0, "ports": [22]},
        "TELNET": {"count": 0, "ports": [23]},
        "DHCP": {"count": 0, "ports": [67, 68]},
        "POP3": {"count": 0, "ports": [110]},
        "IMAP": {"count": 0, "ports": [143]},
        "SMB": {"count": 0, "ports": [445]},
        "NTP": {"count": 0, "ports": [123]},
        "LDAP": {"count": 0, "ports": [389]},
        "SIP": {"count": 0, "ports": [5060, 5061]},
        "RDP": {"count": 0, "ports": [3389]},
        "SSDP": {"count": 0, "ports": [1900]},
        "Other": {"count": 0, "ports": []}
    }

    ipv4_count = 0
    ipv6_count = 0
    total_packets = 0

    for pkt in pcap_file:
        total_packets += 1

        # Layer 2
        if pkt.haslayer(Dot11):
            layer2_counts["Wi-Fi (802.11)"] += 1
        elif pkt.haslayer(Ether):
            eth_type = pkt[Ether].type
            if eth_type in [0x0800, 0x86DD]:
                layer2_counts["Ethernet (802.3)"] += 1
            elif eth_type == 0x0806:
                layer2_counts["ARP"] += 1
            elif eth_type == 0x8100:
                layer2_counts["VLAN"] += 1
            else:
                layer2_counts["Other"] += 1
        else:
            layer2_counts["Other"] += 1

        # IPv4 vs IPv6
        if pkt.haslayer(IP):
            ipv4_count += 1
            proto = pkt[IP].proto
            if proto == 1:
                protocol_counts["ICMP"] += 1
            elif proto == 6:
                protocol_counts["TCP"] += 1
            elif proto == 17:
                protocol_counts["UDP"] += 1
            else:
                protocol_counts["Other"] += 1
        elif pkt.haslayer(IPv6):
            ipv6_count += 1
            if pkt.haslayer("ICMPv6EchoRequest") or pkt.haslayer("ICMPv6EchoReply"):
                protocol_counts["ICMPv6"] += 1
            else:
                protocol_counts["Other"] += 1

        # Application Layer
        ports = ()
        if pkt.haslayer(TCP):
            ports = (pkt[TCP].sport, pkt[TCP].dport)
        elif pkt.haslayer(UDP):
            ports = (pkt[UDP].sport, pkt[UDP].dport)

        matched = False
        for proto, details in app_protocols.items():
            if any(p in ports for p in details["ports"]):
                app_protocols[proto]["count"] += 1
                matched = True
                break
        if not matched:
            app_protocols["Other"]["count"] += 1

    # Totals
    total_layer2 = sum(layer2_counts.values())
    total_layer34 = sum(protocol_counts.values())
    total_app = sum(details["count"] for details in app_protocols.values())

    ipv4_pct = round((ipv4_count / total_packets) * 100, 2) if total_packets else 0
    ipv6_pct = round((ipv6_count / total_packets) * 100, 2) if total_packets else 0

    # Output
    print(bcolors.CYAN + bcolors.BOLD + f"\nTotal Packets: {total_packets}" + bcolors.ENDC)

    # IPv4 vs IPv6
    print(bcolors.CYAN + bcolors.BOLD + f"\nIPv4 vs IPv6:" + bcolors.ENDC)
    if ipv4_count > 0:
        print(bcolors.BLUE + bcolors.BOLD + f"IPv4: " + bcolors.ENDC +
              bcolors.BOLD + f"{ipv4_count} packets ({ipv4_pct}% of total)" + bcolors.ENDC)
    if ipv6_count > 0:
        print(bcolors.BLUE + bcolors.BOLD + f"IPv6: " + bcolors.ENDC +
              bcolors.BOLD + f"{ipv6_count} packets ({ipv6_pct}% of total)" + bcolors.ENDC)

    # Layer 2 Protocols (Sorted by count)
    print(bcolors.CYAN + bcolors.BOLD + f"\nLayer 2 Protocols (Total: {total_layer2}):" + bcolors.ENDC)
    sorted_layer2 = sorted(layer2_counts.items(), key=lambda x: x[1], reverse=True)
    for proto, count in sorted_layer2:
        if count > 0:
            pct_layer = round((count / total_layer2) * 100, 2)
            pct_total = round((count / total_packets) * 100, 2)
            print(bcolors.BLUE + bcolors.BOLD + f"{proto:<25}: " + bcolors.ENDC +
                  bcolors.BOLD + f"{count} packets" + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + f" ({pct_layer}% of Layer 2, {pct_total}% of total)" + bcolors.ENDC)

    # Layers 3 & 4 Protocols (Sorted by count)
    print(bcolors.CYAN + bcolors.BOLD + f"\nLayers 3 & 4 Protocols (Total: {total_layer34}):" + bcolors.ENDC)
    sorted_layer34 = sorted(protocol_counts.items(), key=lambda x: x[1], reverse=True)
    for proto, count in sorted_layer34:
        if count > 0:
            pct_layer = round((count / total_layer34) * 100, 2)
            pct_total = round((count / total_packets) * 100, 2)
            print(bcolors.BLUE + bcolors.BOLD + f"{proto:<25}: " + bcolors.ENDC +
                  bcolors.BOLD + f"{count} packets" + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD + f" ({pct_layer}% of L3/4, {pct_total}% of total)" + bcolors.ENDC)

    # Application Layer Protocols (Sorted by count)
    print(bcolors.CYAN + bcolors.BOLD + f"\nApplication Layer Protocols (Total: {total_app}):" + bcolors.ENDC)
    sorted_app = sorted(app_protocols.items(), key=lambda x: x[1]["count"], reverse=True)
    for proto, details in sorted_app:
        count = details["count"]
        if count > 0:
            pct_layer = round((count / total_app) * 100, 2)
            pct_total = round((count / total_packets) * 100, 2)
            ports_str = ", ".join(str(p) for p in details["ports"]) if details["ports"] else "-"
            print(bcolors.BLUE + bcolors.BOLD + f"{proto:<20} (ports: {ports_str}) : " + bcolors.ENDC +
                 bcolors.BOLD + f"{count} packets" + bcolors.ENDC + bcolors.YELLOW + bcolors.BOLD +  f" ({pct_layer}% of App Layer, {pct_total}% of total)" + bcolors.ENDC)

# -------------------------------------------------------------------------------
# -------------------------------------------------------------------------------

# Run
option_selected = ""
while(option_selected != -1):
    input(bcolors.YELLOW + bcolors.BOLD + "\npress ENTER to display menu" + bcolors.ENDC)

    # Options
    print()
    print(bcolors.BLUE + bcolors.BOLD + "1- Read packet by packet" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "2- Get protocols used in layers 2 & 3 & 4 & 7")
    print(bcolors.BLUE + bcolors.BOLD + "3- Analyze network statistics for a specific IP address" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "4- Gather IP & MAC addresses with MAC vendors" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "5- Gather all queried domain names with their correspoding answers and record types" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "6- Get all DHCP & DNS & Router IP addresses" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "7- Collect usernames & passwords from HTTP, FTP, Telnet, SMTP, POP3, IMAP traffic" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "8- Analyze traffic flow" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "9- Carve files (only works in Linux systems)" + bcolors.ENDC)
    print("-" * 60)
    print(bcolors.RED + bcolors.BOLD + "Attacks Detection" + bcolors.ENDC)
    print("-" * 60)
    print(bcolors.BLUE + bcolors.BOLD + "10- Detect MAC flooding attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "11- Detect MAC spoofing attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "12- Detect ARP spoofing attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "13- Detect FTP brute force attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "14- Detect rogue DHCP server attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "15- Detect DHCP starvation attack" + bcolors.ENDC)
    print(bcolors.BLUE + bcolors.BOLD + "16- Detect DNS poisoning attack" + bcolors.ENDC)
    print()

    option_selected = int(input(bcolors.YELLOW + bcolors.BOLD + "Enter the number of option to perform (-1 to exit): " + bcolors.ENDC))
    match option_selected:
        case 1:
            for packet in pcap_file:
                packet.show()
                print(bcolors.YELLOW + bcolors.BOLD + "-" * 50, "Press ENTER to see the next packet", "-" * 50 + bcolors.ENDC)
                print(bcolors.YELLOW + bcolors.BOLD + "-" * 99, "Input '-1' to exit", "-" * 15 + bcolors.ENDC)
                exit_flag = input()
                try:
                    if int(exit_flag) == -1:
                        break
                except:
                    continue
        case 2:
            get_protocols_used()
        case 3:
            get_ip_address_info()
        case 4:
            extract_ips_macs(pcap_file)
        case 5:
            extract_domain_names(pcap_file)
        case 6:
            get_dhcp_dns_router_addresses(pcap_file)
        case 7:
            get_all_usernames_passwords()
        case 8:
            analyze_traffic_flow()
        case 9:
            carve_files_from_pcap()
        case 10:
            detect_mac_flooding()
        case 11:
            detect_mac_spoofing()
        case 12:
            detect_arp_spoofing()
        case 13:
            detect_ftp_brute_force()
        case 14:
            detect_rogue_dhcp_servers()
        case 15:
            detect_dhcp_starvation()
        case 16:
            detect_dns_poisoning()
# ----------------------------------The End----------------------------------